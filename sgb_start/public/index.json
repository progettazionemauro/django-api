[{"content":"","permalink":"http://localhost:1313/django_retrieve/django_retrieve/","summary":"","title":"My Vue Content"},{"content":"","permalink":"http://localhost:1313/vue_retrieve/vue_retrieve/","summary":"","title":"My Vue Content"},{"content":"","permalink":"http://localhost:1313/data_from_json/data_json/","summary":"","title":"Data From Endpoint"},{"content":"","permalink":"http://localhost:1313/data_from_endpoint/data_from_endpoint/","summary":"","title":"Data_json"},{"content":"Installazione di un tema ed attivazione del sito\nSi fa riferimento al Papermod Theme\nIn ubuntu istallare (This command will install the Go programming language using Snap with classic confinement)\nsudo snap install go --class\nCreate a new Hugo site\nhugo new site MyFreshWebsite --format yaml # replace MyFreshWebsite with name of your website Clonare il tema come modulo Hugo:\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod \u0026ndash;depth=1\nFinally set theme as PaperMod in your site config In config.yml add:\ntheme: [\u0026#34;PaperMod\u0026#34;] After:\nVerify Module Initialization: After running hugo mod init github.com/progettazionemauro/toha, ensure that a go.mod file is created in the root directory of your Hugo project. Check Module Configuration: Open the go.mod file and verify that the module reference for your theme (github.com/progettazionemauro/toha) is listed. Start Hugo Server: Run hugo server to start the Hugo development server. View Your Site: Visit the URL displayed in your terminal to view your site. The theme should automatically be picked up by Hugo since it\u0026rsquo;s imported as a module. Customization: If the theme provides customization options or parameters, you may need to refer to the theme\u0026rsquo;s documentation or source code to understand how to customize it. Depending on how the theme is designed, you may be able to configure it using Hugo parameters or by modifying template files. Since you\u0026rsquo;re using Hugo Modules, you typically don\u0026rsquo;t need to manually specify the theme in your configuration file. Hugo will automatically detect and use the theme module specified in the go.mod file.\nIf you encounter any issues or need specific customization guidance for the theme, it\u0026rsquo;s often helpful to refer to the theme\u0026rsquo;s documentation or reach out to the theme author for assistance.\n","permalink":"http://localhost:1313/posts/il_mio_primo_post/","summary":"Installazione di un tema ed attivazione del sito\nSi fa riferimento al Papermod Theme\nIn ubuntu istallare (This command will install the Go programming language using Snap with classic confinement)\nsudo snap install go --class\nCreate a new Hugo site\nhugo new site MyFreshWebsite --format yaml # replace MyFreshWebsite with name of your website Clonare il tema come modulo Hugo:\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod \u0026ndash;depth=1\nFinally set theme as PaperMod in your site config In config.","title":"Installazione del Tema in Hugo"},{"content":"[toc]\nMARKUP HINTS By Mauro alle h.13:16 I have my README.md inside my project. Here are a method to work with your README.md separately while working on your vsc local project: Use an external Markdown editor like\n** (a minimal markdown editor and reader) **. These editors provide a live preview feature by default.\nBASH trovare la oporta occupata:\nlsof -i :8000 chiudere la porta occupata forzatamente:\nkill -9 32394(esempio) vedere i comandi che iniziano per una determinata strina effettuati in precedenza:\nhistory | grep \u0026quot;kill (esempio)\u0026quot; trovare la porta occupata:\nlsof -i :8000 chiudere la porta occupata forzatamente:\nkill -9 32394(esempio) vedere i comandi che iniziano per una determinata strina effettuati in precedenza:\nhistory | grep \u0026quot;kill (esempio)\u0026quot; Azione Bash - Quello che segue è uno script molto importante che permette nell\u0026rsquo;ordine di 1) verificare se la porta 8000 (che viene utilizzata normalmente in fase di sviluppo) è occupata ed eventualmente chiuderla; 2) aprire Django 3) aprire hugo. Al momento sono presenti due file separati per una migliore comprensione:\n- check_ports.sh \\#!/bin/bash \\# Check if any process is listening on port 8000 if lsof -i :8000 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then ​ echo \u0026#34;Port 8000 is in use.\u0026#34; ​ \\# Get the PID of the process using port 8000 ​ pid=$(lsof -ti :8000) ​ \\# Kill the process ​ echo \u0026#34;Killing process with PID $pid\u0026#34; ​ kill -9 \u0026#34;$pid\u0026#34; ​ echo \u0026#34;Process killed.\u0026#34; else ​ echo \u0026#34;Port 8000 is not in use.\u0026#34; fi run_project.sh #!/bin/bash # Navigate to the Django project directory and run the server # cd /progetto_api python3 manage.py runserver \u0026amp; # Navigate to the Hugo project directory and run the server cd ./sgb_start/ hugo server -D Per cui lo script generare APRIRE I DUE PROGRAMMI DJANGO E HUGO è il seguente (ADA PERFEZIONARE!!):\n#!/bin/bash # Check if any process is listening on port 8000 if lsof -i :8000 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;Port 8000 is in use.\u0026#34; # Get the PID of the process using port 8000 pid=$(lsof -ti :8000) # Kill the process echo \u0026#34;Killing process with PID $pid\u0026#34; kill -9 \u0026#34;$pid\u0026#34; echo \u0026#34;Process killed.\u0026#34; else echo \u0026#34;Port 8000 is not in use.\u0026#34; fi # Navigate to the Django project directory and run the server # cd /progetto_api python3 manage.py runserver \u0026amp; # Navigate to the Hugo project directory and run the server cd ./sgb_start/ hugo server -D Mentre il codice per chiudere i due programmi DJANGO e HUGO è il seguente (da perfezionare)!!!:\n# Find Django PID and send SIGTERM signal django_pid=$(pidof python) \u0026amp;\u0026amp; kill \u0026#34;$django_pid\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Django process terminated\u0026#34; # Find Hugo PID and send SIGTERM signal hugo_pid=$(pidof hugo) \u0026amp;\u0026amp; kill \u0026#34;$hugo_pid\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Hugo process terminated\u0026#34; ps aux | grep \u0026#34;python manage.py runserver\u0026#34;; reset GIT \u0026amp; GITHUB Riferimenti Mastering MarkDown\nRicordarsi di aggiungere .gitgnore - git add .gitignore - git commit -m \u0026ldquo;Add .gitignore to exclude compiled Python files\u0026rdquo;\nPer effettuare il push da origine a remoto - git push origin implementazione-pagina\nSwitch to the New Branch: - git checkout new-branch-name\nCreare una nuova branch e posizionarsi sulla stessa git checkout -b new-branch-name (Il comando può essere visto come la sintesi dei due seguenti comandi:) - git branch new-branch-name # Create a new branch - git checkout new-branch-name # Switch to the new branch\nYou\u0026rsquo;ve created a new branch (template-tutorial) without committing changes on your existing branch (implementazione-pagina) To address this, you\u0026rsquo;ll need to follow these steps to commit your changes on the implementazione-pagina branch and then switch back to the template-tutorial branch. Here\u0026rsquo;s a step-by-step guide:\nCommit Changes on implementazione-pagina: Assuming you are currently on the template-tutorial branch, ** switch back to the implementazione-pagina branch:** git checkout implementazione-pagina\nNow, add and commit your changes:\ngit add . git commit -m \u0026quot;Your commit message here\u0026quot;\nPush Changes to Remote (implementazione-pagina): Assuming the remote branch is named implementazione-pagina: git push origin implementazione-pagina\n** Switch Back to template-tutorial:** Now, switch back to the template-tutorial branch: git checkout template-tutorial\nIf you haven\u0026rsquo;t pushed the template-tutorial branch yet, you can push it to the remote repository when you\u0026rsquo;re ready:\ngit push origin template-tutorial\nHow can see from my vsc local if a git branch is present also in the remote github?\ngit fetch --all git branch -a This fetches all branches from the remote repository and lists both local and remote branches. Remote branches are prefixed with \u0026ldquo;remotes/origin/\u0026rdquo;. Check if your branch is listed among the remotes.\nCome posso creare una nuova branch in local, e poi crearla anche in Github, poi effettuare il push e rendere questa branch principale?\nCreate a new branch locally and switch to it (chimiamo la nuova branch template-tutorial): git checkout -b template-tutorial\nPush the new branch to GitHub:\ngit push origin template-tutorial\nSet the upstream for the new branch:\ngit branch --set-upstream-to=origin/template-tutorial template-tutorial![alt]( \u0026lsquo;{\u0026ldquo;class\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;title\u0026rdquo;: \u0026ldquo;\u0026rdquo;}\u0026rsquo;)\nNow, further pushes can be simplified to:\ngit push\nTo revert the changes and go back to the original commit before the changes, you can use the following commands: git reset --hard HEAD git clean -fd\nThe first command (git reset \u0026ndash;hard HEAD) resets your branch to the latest commit, discarding changes. The second command (git clean -fd) removes untracked files and directories. Use them with caution, as they are not reversible.\n-fd stands for what? In the context of the git clean command:\n-f stands for force. -d stands for directory. Together, -fd means force removal of untracked directories. This option is used to remove untracked files and directories forcefully.\ndelete a local branch and also delete it on the remote repository on GitHub Delete the local branch:\ngit branch -d branch_name![alt]( \u0026lsquo;{\u0026ldquo;class\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;title\u0026rdquo;: \u0026ldquo;\u0026rdquo;}\u0026rsquo;)\nReplace branch_name with the name of the branch you want to delete.\nIf the branch contains unmerged changes, you might need to force delete it:\ngit branch -D branch_name\nDelete the remote branch:\ngit push origin --delete branch_name\nThis will delete the branch on the remote repository (GitHub).\nUpdate your local repository to reflect the changes on the remote:\ngit fetch --prune\nThe \u0026ndash;prune flag removes any remote tracking branches that no longer exist on the remote.\nI want to synch another an oldest branch named \u0026ldquo;template-tutorial\u0026rdquo; with a newest branch named template-sheetlike and after delete this last one (template-sheetlike) Switch to the template-tutorial branch: git switch template-tutorial\nRebase template-sheetlike onto template-tutorial: git rebase template-sheetlike\nPush the changes to the remote repository: git push origin template-tutorial --force Note: Force-pushing after a rebase rewrites the commit history. Use it with caution, especially if the branch has already been shared with others\nDelete the template-sheetlike branch: git branch -d template-sheetlike git push origin --delete template-sheetlike\nAutomate the copy of a file from a repo to another when pushing the commit So let\u0026rsquo;s say that i have cheatsheet.md that i update regularly as it would be a wiki page. This file with the same name is present on different local repo. Let\u0026rsquo;s say that i am working into my local repo named /home/mauro/Scrivania/dJANGO_apI/progetto_api/cheatsheet.md.md. When I do a commit adn after a push into github repo https://github.com/progettazionemauro/django-api I want automatically copy this file and update the commit also into my https://github.com/progettazionemauro/wiki-wag How can do that automatically?\nTo automatically copy and update the cheatsheet.md file in another GitHub repository whenever you push changes to the first repository, you can use GitHub Actions. GitHub Actions allows you to define workflows that run in response to various events, such as pushing to a repository. Here\u0026rsquo;s a simple example:\nTheory Create a GitHub Actions Workflow: In your Django API repository (https://github.com/progettazionemauro/django-api), create a directory named .github/workflows if it doesn\u0026rsquo;t already exist.\nInside this directory, create a file named, for example, sync_cheatsheet.yml with the following content:\nname: Sync Cheatsheet on: push: branches: - main jobs: sync: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Copy cheatsheet to other repository run: | cp cheatsheet.md /path/to/wiki-wag-repo cd /path/to/wiki-wag-repo git config user.email \u0026#34;your-email@example.com\u0026#34; git config user.name \u0026#34;Your Name\u0026#34; git add cheatsheet.md git commit -m \u0026#34;Sync cheatsheet from django-api repository\u0026#34; git push origin main Replace /path/to/wiki-wag-repo with the actual path to your local wiki-wag repository.\nCommit and Push Workflow:\nCommit the changes and push them to your Django API repository:\ngit add .github/workflows/sync_cheatsheet.yml git commit -m \u0026#34;Add sync cheatsheet workflow\u0026#34; git push origin main Run the Workflow:\nThe workflow will run automatically when you push changes to the main branch. It will copy the cheatsheet.md file to the specified path in the wiki-wag repository and commit the changes there.\nMake sure to replace the placeholder values in the workflow file (your-email@example.com, Your Name, and /path/to/wiki-wag-repo) with your actual email, name, and the path to the wiki-wag repository.\nHere are step-by-step instructions to set up the GitHub Actions workflow for syncing the cheatsheet.md file from the Django API repository to the wiki-wag repository:\nStep 1: Create the Workflow File Open your Django API repository in your code editor or on GitHub.\nInside the .github/workflows directory (create it if it doesn\u0026rsquo;t exist), create a new file named, for example, sync_cheatsheet.yml.\nCopy and paste the following content into sync_cheatsheet.yml:\nyamlCopy codename: Sync Cheatsheet on: push: branches: - main jobs: sync: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Copy cheatsheet to other repository run: | cp cheatsheet.md /path/to/wiki-wag-repo cd /path/to/wiki-wag-repo git config user.email \u0026#34;your-email@example.com\u0026#34; git config user.name \u0026#34;Your Name\u0026#34; git add cheatsheet.md git commit -m \u0026#34;Sync cheatsheet from django-api repository\u0026#34; git push origin main Replace /path/to/wiki-wag-repo, \u0026quot;your-email@example.com\u0026quot;, and \u0026quot;Your Name\u0026quot; with the actual path to your local wiki-wag repository, your email, and your GitHub username.\nStep 2: Commit and Push Workflow File In your terminal, navigate to the Django API repository.\nRun the following commands to stage, commit, and push the workflow file:\nbashCopy codegit add .github/workflows/sync_cheatsheet.yml git commit -m \u0026#34;Add sync cheatsheet workflow\u0026#34; git push origin main Step 3: Run the Workflow Visit the Actions tab on your GitHub repository to see the status of your workflow. You should see the \u0026ldquo;Sync Cheatsheet\u0026rdquo; workflow running or completed. Step 4: Verify Changes in the wiki-wag Repository After the workflow completes, check your wiki-wag repository for the synced changes to the cheatsheet.md file.\nIf there are any issues or changes are not reflected as expected, review the GitHub Actions logs for the workflow to identify potential errors.\nThat\u0026rsquo;s it! You\u0026rsquo;ve set up a GitHub Actions workflow to automatically sync the cheatsheet.md file from the Django API repository to the wiki-wag repository on each push to the main branch.\nBreak down the content of the GitHub Actions workflow file step by step: name: Sync Cheatsheet This line sets the name of the GitHub Actions workflow to \u0026ldquo;Sync Cheatsheet.\u0026rdquo; push: branches: - main This section specifies the trigger for the workflow. The workflow will be triggered on each push to the main branch. sync: runs-on: ubuntu-latest Here, we define a job named \u0026ldquo;sync\u0026rdquo; that will run on the latest version of the Ubuntu operating system. steps: - name: Checkout repository uses: actions/checkout@v2 This step checks out the code from the repository, allowing subsequent steps to operate on the repository\u0026rsquo;s contents. uses: actions/checkout@v2: This part specifies the action that will be used for this step. In GitHub Actions, an action is a reusable unit of code. The actions/checkout action is provided by GitHub and is commonly used to check out the source code of the repository. @v2: This refers to the version of the actions/checkout action to use. In this case, it\u0026rsquo;s version 2 of the action. The @v2 is a version tag that indicates a specific release or version of the action. Using a version tag ensures that the workflow is using a stable and known version of the action, making it less prone to unexpected changes. - name: Copy cheatsheet to other repository run: | cp cheatsheet.md /path/to/wiki-wag-repo cd /path/to/wiki-wag-repo In this step, the cheatsheet.md file is copied from the current repository to the specified path (/path/to/wiki-wag-repo). The subsequent commands are executed within the wiki-wag repository. git config user.email \u0026#34;your-email@example.com\u0026#34; git config user.name \u0026#34;Your Name\u0026#34; These commands set the global Git configuration for the user\u0026rsquo;s email and name in the wiki-wag repository. git add cheatsheet.md This command stages the changes to the cheatsheet.md file for the next commit. git commit -m \u0026#34;Sync cheatsheet from django-api repository\u0026#34; This command creates a new commit with a commit message indicating that the cheatsheet.md file is being synced from the django-api repository. git push origin main Finally, this command pushes the changes to the remote repository (origin) on the main branch.\nReal Case: If I have another branch othe then main in repo2 I can do it: name: Sync Cheatsheet on: push: branches: - main jobs: sync: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 with: ref: opzione-pagina # Specify the branch you want to sync Summary The GitHub Actions workflow automates the process of syncing the cheatsheet.md file from the django-api repository to the wiki-wag repository. It does so by copying the file, committing the changes, and pushing the commit to the main branch of the wiki-wag repository whenever changes are pushed to the main branch of the django-api repository.\nSome useful notes Merge: Creates Merge Commits: When you merge one branch into another, Git creates a new merge commit that has two parent commits: one from the branch you\u0026rsquo;re merging and another from the branch you\u0026rsquo;re merging into. This results in a non-linear history with multiple branches merging into each other Preserves Original History:\nThe original commits from both branches remain unchanged. This approach keeps a clear record of when changes were made on each branch.\nRebase: Linearizes History:\nRebase is used to linearize the commit history. It moves or combines a sequence of commits to a new base commit. When you rebase one branch onto another, it effectively transplants the entire branch onto the tip of the other branch, creating a linear history. No Merge Commits:\nUnlike merge, rebase doesn\u0026rsquo;t create additional merge commits. It can result in a cleaner, more linear history. When to Choose Each Approach: Merge:\nUse merge when you want to preserve the original commit history, especially when collaborating with others. Good for feature branches and when you want to maintain a clear record of branch integration points. Rebase:\nUse rebase when you want a clean, linear history and don\u0026rsquo;t mind rewriting commits. Useful for feature branches before merging into a shared branch to avoid unnecessary merge commits. Switch vs. Checkout: git switch is a more modern and user-friendly command introduced in recent versions of Git. It is designed specifically for branch switching. If you\u0026rsquo;re using a version of Git that supports git switch, you can replace git checkout with git switch:\nSwitching Branch: git switch template-tutorial Both commands essentially do the same thing in this context, but git switch provides a clearer and more explicit syntax for branch-related operations. If your Git version supports it, feel free to use git switch instead of git checkout.\nGIT CHEATSHEET git command to see the last 3 commit with oneline :\ngit log --oneline -n 3 HOOKS Hook per sincronizzare un file di testo da stckbit con l\u0026rsquo;intera directory proveniente dal local. Questo script è molto potente in quanto selettivamente recupera dal remote il file di interesse lo sovrascrive forzatamente nella locale e poi qualsiasi cambio in local sul file non viene considerato ## Mauro 1/5/24 - h. 13:11 #!/bin/bash # Fetch latest changes from the remote repository git fetch origin # Pull the latest version of cheatsheet.md from the remote and overwrite local changes git pull origin main --force # Remove any local changes to cheatsheet.md git checkout -- cheatsheet.md # Continue with the rest of the script # Add all changes to the staging area git add . # Commit all staged changes git commit -m \u0026#34;Auto-commit before pushing changes\u0026#34; # Push the commit to the remote repository git push origin main WAGTAIL How to use StreamField for mixed content StreamField block reference Templating - Jinja Wrinting Templates La regola da seguire è questa:\ncode: class wagtail.fields.StreamField(blocks, use_json_field=None, blank=False, min_num=None, max_num=None, block_counts=None, collapsed=False)\nE questa la spiegazione:\nclass wagtail.fields.StreamField: This line defines a class named StreamField in the wagtail.fields module.\n(blocks, use_json_field=None, blank=False, min_num=None, max_num=None, block_counts=None, collapsed=False): These are the parameters that the StreamField class constructor (init method) accepts. Let\u0026rsquo;s go through each one:\nblocks: This is a required parameter. It represents the blocks that can be used in the stream. It seems like it should be provided when creating an instance of StreamField.\nuse_json_field=None: This is an optional parameter with a default value of None. It allows you to specify whether to use a JSON field for storage. If not provided, it defaults to None.\nblank=False: This is an optional parameter with a default value of False. It indicates whether the field is allowed to be blank when used in a form. If not provided, it defaults to False.\nmin_num=None: This is an optional parameter with a default value of None. It specifies the minimum number of blocks required. If not provided, it defaults to None.\nmax_num=None: This is an optional parameter with a default value of None. It specifies the maximum number of blocks allowed. If not provided, it defaults to None.\nblock_counts=None: This is an optional parameter with a default value of None. It seems related to counting blocks. If not provided, it defaults to None.\ncollapsed=False: This is an optional parameter with a default value of False. It indicates whether the blocks should be collapsed in the Wagtail admin interface. If not provided, it defaults to False\nCosì ad esempio per questo codice. Possiamo effettuare il breakdown di questo codice in base alla regola definita:\n`class BlogPage(Page): author = models.CharField(max_length=255, default=\u0026lsquo;Default Author\u0026rsquo;) date = models.DateField(\u0026ldquo;Post date\u0026rdquo;)\nbody = StreamField( [ ('heading', blocks.CharBlock(form_classname=\u0026quot;title\u0026quot;)), ('paragraph', blocks.RichTextBlock()), ('image', ImageChooserBlock()), ('code', CodeBlock()), ('raw_html', RawHTMLBlock()), ], use_json_field=True ) content_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('body'), ] `\nauthor = models.CharField(max_length=255, default=\u0026lsquo;Default Author\u0026rsquo;): This line defines a character field named author in the BlogPage class. It has a maximum length of 255 characters and a default value of \u0026lsquo;Default Author\u0026rsquo;.\ndate = models.DateField(\u0026ldquo;Post date\u0026rdquo;): This line defines a date field named date in the BlogPage class with a human-readable name \u0026ldquo;Post date\u0026rdquo;.\nbody = StreamField([\u0026hellip;], use_json_field=True): This line defines a stream field named body in the BlogPage class. It allows the inclusion of different block types, such as CharBlock, RichTextBlock, ImageChooserBlock, CodeBlock, and RawHTMLBlock. The use_json_field parameter is set to True, indicating that a JSON field will be used for storage.\ncontent_panels = Page.content_panels + [\u0026hellip;]: This line defines the content panels for the Wagtail admin interface. It includes panels for \u0026lsquo;author\u0026rsquo;, \u0026lsquo;date\u0026rsquo;, and \u0026lsquo;body\u0026rsquo;.\nPoi in particolare:\ncontent_panels definition in the BlogPage class: content_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('body'), ]\nPage.content_panels: This part includes the content panels defined in the parent Page class. It allows the inclusion of standard page fields, such as title, slug, publish date, etc.\nFieldPanel(\u0026lsquo;author\u0026rsquo;): This adds a panel for the author field to the content panels. It\u0026rsquo;s likely a simple text input for the author\u0026rsquo;s name.\nFieldPanel(\u0026lsquo;date\u0026rsquo;): This adds a panel for the date field, probably a date picker for selecting the post date.\nFieldPanel(\u0026lsquo;body\u0026rsquo;): This adds a panel for the body field. Since it\u0026rsquo;s a StreamField, it might include a dynamic set of blocks like headings, paragraphs, images, code blocks, and raw HTML.\nUso dello StructBox in Wagtail Example Model with StructBlock Consider a simple model for a page with a StreamField containing a StructBlock named \u0026lsquo;person\u0026rsquo;:\n` # models.py from django.db import models from wagtail.core.fields import StreamField from wagtail.core import blocks from wagtail.images.blocks import ImageChooserBlock from wagtail.core.models import Page from wagtail.admin.edit_handlers import FieldPanel, StreamFieldPanel\nclass BlogPage(Page): body = StreamField([ (\u0026lsquo;person\u0026rsquo;, blocks.StructBlock([ (\u0026lsquo;first_name\u0026rsquo;, blocks.CharBlock()), (\u0026lsquo;surname\u0026rsquo;, blocks.CharBlock()), (\u0026lsquo;photo\u0026rsquo;, ImageChooserBlock(required=False)), (\u0026lsquo;biography\u0026rsquo;, blocks.RichTextBlock()), ])), (\u0026lsquo;heading\u0026rsquo;, blocks.CharBlock(form_classname=\u0026ldquo;title\u0026rdquo;)), (\u0026lsquo;paragraph\u0026rsquo;, blocks.RichTextBlock()), (\u0026lsquo;image\u0026rsquo;, ImageChooserBlock()), ], use_json_field=True)\ncontent_panels = Page.content_panels + [ StreamFieldPanel('body'), ] `\u0026lt;/span\u0026gt; Diagram Explanation Blog Page with StreamField and StructBlock:\nA BlogPage contains a StreamField named \u0026lsquo;body\u0026rsquo;. \u0026lsquo;body\u0026rsquo; includes various block types, one of which is a StructBlock named \u0026lsquo;person\u0026rsquo;. Person StructBlock:\nThe \u0026lsquo;person\u0026rsquo; block is a StructBlock containing fields like \u0026lsquo;first_name\u0026rsquo;, \u0026lsquo;surname\u0026rsquo;, \u0026lsquo;photo\u0026rsquo;, and \u0026lsquo;biography\u0026rsquo;. Block Instances:\nWhen editing a BlogPage, you can add multiple instances of different block types, including \u0026lsquo;person\u0026rsquo;. Each \u0026lsquo;person\u0026rsquo; block instance can have its own \u0026lsquo;first_name\u0026rsquo;, \u0026lsquo;surname\u0026rsquo;, \u0026lsquo;photo\u0026rsquo;, and \u0026lsquo;biography\u0026rsquo;\nTemplate Implementation\nTo render this in a template, you can use the following:\n`\u0026lt;!-- templates/blog_page.html --\u0026gt; {% extends \u0026#34;base.html\u0026#34; %} {% block content %} \u0026lt;article\u0026gt; {% for block in page.body %} {% if block.block_type == \u0026#39;person\u0026#39; %} \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; {% if block.value.photo %} {% image block.value.photo width-400 %} {% endif %} \u0026lt;h2\u0026gt;{{ block.value.first_name }} {{ block.value.surname }}\u0026lt;/h2\u0026gt; {{ block.value.biography }} \u0026lt;/div\u0026gt; {% else %} {# Rendering for other block types #} \u0026lt;section class=\u0026#34;{{ block.block_type }}\u0026#34;\u0026gt; {% include_block block %} \u0026lt;/section\u0026gt; {% endif %} {% endfor %} \u0026lt;/article\u0026gt; {% endblock %} Database Initialization\nWhen you run makemigrations and migrate after adding the StructBlock to your model, the necessary database tables and fields are created. The use_json_field=True parameter in the StreamField indicates that the data for the StreamField will be stored as JSON in the database.\nHere\u0026rsquo;s how you perform the migration:\nbash Copy code python manage.py makemigrations python manage.py migrate After migration, you can create or edit a BlogPage instance through the Wagtail admin interface. The StructBlock fields will be part of the form for each \u0026lsquo;person\u0026rsquo; block within the \u0026lsquo;body\u0026rsquo; StreamField.\nRiferimenti Rapidi Wagtail Caso Studio web page How to use Streamfield for mixed content StreamFieldBlock Reference Caratteristiche avanzate di Diango - Wagtail Uno dei porblemi che si incontrano effettuando delle tabelle all\u0026rsquo;interno di wagtail ma in generale anche in Django è il caso pratico della renderizzazione degli headers di una tabella se si vogliono recuperare ad esempio i dati all\u0026rsquo;interno delle celle della tabella.\nQuesto codice di esempio effettua il debug su ciò che è successo:\n` {% for column in block.value.columns %} {{ column.header|default:\u0026ldquo;Column Header\u0026rdquo; }}\n\u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: {{ block.value.rows|list }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: {{ block.value.rows|list.1|default:\u0026quot;\u0026quot; }}\u0026lt;/p\u0026gt; {% with block.value.rows|list.1|default:\u0026quot;\u0026quot; as row_values %} {{ row_values.0|default:\u0026quot;\u0026quot; }} {% endwith %} \u0026lt;/th\u0026gt; {% endfor %} \u0026lt;/tr\u0026gt; \u0026lt;th\u0026gt; Column Header \u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: \u0026amp;lt;generator object TypedTable.rows at 0x7f08958de2e0\u0026amp;gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: \u0026lt;/p\u0026gt; ` Approfondendo la ricerca si artriva a tale indicazione :::caution The issue seems to be related to the fact that block.value.rows is a generator object. In Python, generators are lazy and can be consumed only once. If you try to iterate through the generator more than once, you will get an empty result on subsequent iterations.\nIn your case, it seems like the generator has been consumed once, which is why when you try to access block.value.rows.1, it doesn\u0026rsquo;t contain any values.\nTo address this issue, you might want to convert the generator to a list so that you can iterate through it multiple times. However, since you are using the TypedTableBlock from wagtail.contrib.typed_table_block, you might need to adjust how you access the rows.\nHere is a modification that converts the generator to a list before using it:\ndjango Copy code\n\u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: {{ block.value.rows|list }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: {{ block.value.rows|list.1|default:\u0026quot;\u0026quot; }}\u0026lt;/p\u0026gt; {% with block.value.rows|list.1|default:\u0026quot;\u0026quot; as row_values %} {{ row_values.0|default:\u0026quot;\u0026quot; }} {% endwith %} \u0026lt;/th\u0026gt; {% endfor %} \u0026lt;/tr\u0026gt; WAGTAIL Upgrade process We recommend upgrading one feature release at a time, even if your project is several versions behind the current one. This has a number of advantages over skipping directly to the newest release:\nIf anything breaks as a result of the upgrade, you will know which version caused it, and will be able to troubleshoot accordingly;\nDeprecation warnings shown in the console output will notify you of any code changes you need to make before upgrading to the following version;\nSome releases make database schema changes that need to be reflected on your project by running ./manage.py makemigrations - this is liable to fail if too many schema changes happen in one go.\nBefore upgrading to a new feature release:\nCheck your project’s console output for any deprecation warnings, and fix them where necessary;\nCheck the new version’s release notes, and the Compatible Django / Python versions table below, for any dependencies that need upgrading first;\nMake a backup of your database.\nTo upgrade:\nUpdate the wagtail line in your project’s requirements.txt file to specify the latest patch release of the version you wish to install. For example, to upgrade to version 1.8.x, the line should read: `wagtail\u0026gt;=1.8,\u0026lt;1.9 Run:\npip install -r requirements.txt ./manage.py makemigrations ./manage.py migrate`\nMake any necessary code changes as directed in the “Upgrade considerations” section of the release notes.\nTest that your project is working as expected.\nRemember that the JavaScript and CSS files used in the Wagtail admin may have changed between releases - if you encounter erratic behaviour on upgrading, ensure that you have cleared your browser cache. When deploying the upgrade to a production server, be sure to run ./manage.py collectstatic to make the updated static files available to the web server. In production, we recommend enabling ManifestStaticFilesStorage in the STATICFILES_STORAGE setting - this ensures that different versions of files are assigned distinct URLs.\nWAGTAIL COMPATIBILITY WITH DJANGO - link PYTHON Spiegazione attraverso codice di init, getattribute e super Spesso nei moduli di wagtail si fa riferimento alla classazione e subclassazione. Avere chiri alcuni termini è necessario. Questa è la breve sintesi attraverso un sempio\nclass Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;)` This is a simple class representing a vehicle with a brand. It has an init method that initializes the brand attribute and a start method to print a message when the vehicle starts. Car (inherits from Vehicle):\npython Copy code class Car(Vehicle): def init(self, brand, model): # No use of super() ​ self.model = model\ndef start(self): print(f\u0026quot;{self.brand} {self.model} car started.\u0026quot;) This class represents a specific type of vehicle, a Car, inheriting from the Vehicle class. It has its own init method, but it doesn\u0026rsquo;t use super(), and it has a start method that overrides the start method in the Vehicle class. CarWithSuper (inherits from Car):\nclass CarWithSuper(Car): def init(self, brand, model, color): super().init(brand, model) self.color = color\ndef start(self): super().start() print(f\u0026quot;The {self.color} car is ready to go.\u0026quot;) def __getattribute__(self, name): # Modifying __getattribute__ to add a prefix to the brand attribute if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__(name) else: return super().__getattribute__(name) This class inherits from Car and introduces a new attribute color. It uses super() in the init method to call the init method of the parent class (Car). It overrides the start method, calls the parent\u0026rsquo;s start method using super(), and adds an additional message. It also modifies getattribute to add a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the brand attribute. Examples: Example without super(), init, and getattribute:\ncar_without_super = Car(brand=\u0026quot;Toyota\u0026quot;, model=\u0026quot;Camry\u0026quot;) print(car_without_super.model) # Output: Camry An instance of Car is created without using super(). __init__ in Car is called, but __init__ of the parent (Vehicle) is not called. start method from Vehicle is not available in car_without_super. Example with super(), __init__, and __getattribute__: car_with_super = CarWithSuper(brand=\u0026quot;Ford\u0026quot;, model=\u0026quot;Mustang\u0026quot;, color=\u0026quot;red\u0026quot;) print(car_with_super.brand) # Output: Awesome Ford car_with_super.start() # Output: Ford Mustang car started. The red car is ready to go.\nAn instance of CarWithSuper is created using super() to call init of the parent (Car). getattribute is modified to add a prefix to the brand attribute. start method calls the parent\u0026rsquo;s (Car) start method using super() and adds an additional message. Roles:\ninit: Used for initializing the attributes of an object. In the inheritance chain, it\u0026rsquo;s common to use super().init(\u0026hellip;) to call the initializer of the parent class.\ngetattribute: Called whenever an attribute of an object is accessed. Can be modified to customize attribute access. Used here to modify the behavior of accessing the brand attribute.\nsuper(): Used to refer to the parent class. In init, it\u0026rsquo;s used to call the initializer of the parent class. In methods, it\u0026rsquo;s used to call methods from the parent class. In the provided example, super() helps maintain the hierarchy in inheritance, ensuring that the methods of the parent classes are appropriately called. init is used for object initialization, and getattribute is modified to customize attribute access.\nVediamo ora cosa succede se non utilizziamo i metodi Assenza di init If you don\u0026rsquo;t use the init method in the Vehicle class, the class will still be valid, but instances of the class won\u0026rsquo;t have a constructor to initialize their state. The init method is a special method in Python classes that is automatically called when an object is created. It is used for initializing the attributes of the object.\nHere\u0026rsquo;s what happens when you don\u0026rsquo;t include init:\npython Copy code class Vehicle: def start(self): print(\u0026ldquo;Vehicle started.\u0026rdquo;)\nCreating an instance without init vehicle_instance = Vehicle()\nThis will not raise an error, but the instance won\u0026rsquo;t have a \u0026lsquo;brand\u0026rsquo; attribute. If you try to access \u0026lsquo;brand\u0026rsquo;, it will result in an AttributeError. print(vehicle_instance.start()) # Output: Vehicle started. print(vehicle_instance.brand) # AttributeError: \u0026lsquo;Vehicle\u0026rsquo; object has no attribute \u0026lsquo;brand\u0026rsquo; In the example above, creating an instance of Vehicle without an init method is allowed. However, without an init method, instances won\u0026rsquo;t have any attributes initialized during instantiation. If you try to access an attribute that hasn\u0026rsquo;t been defined, you will get an AttributeError.\nIncluding the init method allows you to initialize the state of an object when it is created. For example:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) Creating an instance with init vehicle_instance = Vehicle(brand=\u0026ldquo;Toyota\u0026rdquo;)\nNow, the 'brand' attribute is initialized during instantiation. print(vehicle_instance.start()) # Output: Toyota vehicle started. print(vehicle_instance.brand) # Output: Toyota In the second example, the init method is used to initialize the brand attribute when a Vehicle instance is created. This ensures that the instance has a properly initialized state from the beginning.\nEd ora quando posso usare e non usare getattribute? If you don\u0026rsquo;t define the getattribute method in a class, Python will use the default behavior for attribute access. The default behavior involves looking up the attribute in the object\u0026rsquo;s dictionary and returning its value if found. If the attribute is not found in the object\u0026rsquo;s dictionary, Python looks for the attribute in the class hierarchy.\nHere\u0026rsquo;s what happens if you don\u0026rsquo;t use getattribute:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) Creating an instance without getattribute vehicle_instance = Vehicle(brand=\u0026ldquo;Toyota\u0026rdquo;)\nAccessing the \u0026lsquo;brand\u0026rsquo; attribute without a custom getattribute print(vehicle_instance.brand) # Output: Toyota\nThe default behavior is used, and there is no need for a custom getattribute in this case. In the example above, we create a Vehicle class with an init method to initialize the brand attribute. When we access the brand attribute, the default attribute access behavior is used, and there is no need for a custom getattribute. The attribute is found in the instance\u0026rsquo;s dictionary, and its value is returned.\nThe getattribute method is a powerful tool for customizing attribute access, and it allows you to intercept attribute access calls and customize the behavior. However, in many cases, you may not need to override it, and the default behavior is sufficient for basic attribute access. Only when you need to customize the attribute access behavior should you consider defining a getattribute method.\nIn the example provided, the getattribute method is used to customize the behavior of accessing the brand attribute in the CarWithSuper class. Specifically, it adds a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the value of the brand attribute before returning it.\nHere\u0026rsquo;s the relevant part of the code:\npython Copy code class CarWithSuper(Car): # \u0026hellip;\ndef __getattribute__(self, name): # Modifying __getattribute__ to add a prefix to the brand attribute if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__(name) else: return super().__getattribute__(name) In this case, the getattribute method is modifying the behavior of accessing the brand attribute. Without this customization, accessing car_with_super.brand would simply return the value of the brand attribute. With the custom getattribute, it returns the value with the added prefix.\nSo, you might need to use getattribute when you want to customize or intercept attribute access calls and modify the behavior based on your specific requirements. It\u0026rsquo;s a powerful tool, but it should be used judiciously, as unnecessary or incorrect use may lead to unexpected behavior and potential issues.\nMIXIN L\u0026rsquo;esempio esposto e che di seguito si ripropone risulta anche un ottimo esempio di mixin\nYes, the provided example with Vehicle, Car, and CarWithSuper can be considered an example of mixin-like behavior. Let me break it down:\nVehicle Class:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) This is the base class representing a generic vehicle. It has an init method to initialize the brand attribute and a start method.\nCar Class (Inherits from Vehicle):\npython Copy code class Car(Vehicle): def init(self, brand, model): super().init(brand) self.model = model\ndef start(self): print(f\u0026quot;{self.brand} {self.model} car started.\u0026quot;) The Car class inherits from Vehicle. It has its own init method but uses super() to call the init method of the parent class (Vehicle). It also has its own start method, overriding the start method of Vehicle.\nCarWithSuper Class (Inherits from Car):\npython Copy code class CarWithSuper(Car): def init(self, brand, model, color): super().init(brand, model) self.color = color\ndef start(self): super().start() print(f\u0026quot;The {self.color} car is ready to go.\u0026quot;) def __getattribute__(self, name): if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__('brand') else: return super().__getattribute__(name) The CarWithSuper class inherits from Car and introduces a new attribute (color). It uses super() to call the init method of the parent class (Car). It also overrides the start method, calling the parent\u0026rsquo;s (Car) start method using super() and adding an additional message. Additionally, it modifies getattribute to add a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the brand attribute.\nSo, in this example, the classes are organized in a way that exhibits mixin-like behavior. The CarWithSuper class enhances the behavior of the Car class by adding attributes and modifying methods, and it uses super() to maintain the hierarchy and call methods from parent classes. While it may not strictly adhere to the classic definition of a mixin, it shares some characteristics of mixin-like behavior.\nDefinizione di mixin In object-oriented programming, a mixin is a class that provides a certain functionality to be inherited by a subclass, but is not meant to stand alone. Mixins are used to enhance the functionality of a class without the need for multiple inheritance.\nHere are some key characteristics and features of mixins:\nPurpose-Specific Functionality: Mixins are designed to provide a specific set of functionalities or behaviors that can be easily added to other classes. They encapsulate a piece of behavior.\nReusability: Mixins promote code reuse. Instead of duplicating code in multiple classes, you can create a mixin and include it in various classes that need that particular behavior.\nNo Standalone Use: Mixins are not meant to be instantiated or used independently. They lack the complete implementation to be used as standalone classes. They are intended to be combined with other classes.\nFlexible Composition: Since a class can inherit from multiple mixins, it allows for flexible composition of functionalities. This is in contrast to languages that do not support multiple inheritance directly.\nAvoids Diamond Problem: Mixins can help avoid the \u0026ldquo;diamond problem\u0026rdquo; that arises in languages with multiple inheritance, where a class inherits from two classes that have a common ancestor.\nSmall and Focused: Mixins are typically small and focused on a specific task. This makes them easy to understand, maintain, and reuse.\nSTANDARD COMMANDS IN DJANGO INSTALLATION# python3 -m venv venv USEFUL PROPERTY AND METHOD IN DJANGO L\u0026rsquo;uso di Queryset Django querysets have several notable properties and methods that provide flexibility and ease of use when interacting with the database. Here are some key properties and methods of querysets:\nChaining:\nQuerysets are lazy, meaning they don\u0026rsquo;t hit the database until an action is performed. Multiple filters and operations can be chained together to build complex queries. Example:\npython Copy code queryset = Model.objects.filter(field1=value1).exclude(field2=value2).order_by(\u0026rsquo;-date_created\u0026rsquo;) Slicing:\nQuerysets can be sliced to retrieve a specific range of objects. Example:\npython Copy code queryset = Model.objects.all() result_slice = queryset[5:10] # Retrieve objects 5 through 9 Count:\nThe count method returns the number of objects in the queryset without fetching the actual objects. Example:\npython Copy code count = queryset.count() Distinct:\nThe distinct method eliminates duplicate rows from the queryset. Example:\npython Copy code distinct_values = Model.objects.values(\u0026lsquo;field\u0026rsquo;).distinct() Aggregate:\nThe aggregate method allows for the calculation of aggregate values (e.g., sum, average) on the queryset. Example:\npython Copy code from django.db.models import Avg average_value = Model.objects.aggregate(avg_value=Avg(\u0026rsquo;numeric_field\u0026rsquo;)) Values and ValuesList:\nThe values method returns a queryset of dictionaries representing the values of specific fields. The values_list method returns a queryset of tuples representing the values of specific fields. Example:\npython Copy code values_queryset = Model.objects.values(\u0026lsquo;field1\u0026rsquo;, \u0026lsquo;field2\u0026rsquo;) values_list_queryset = Model.objects.values_list(\u0026lsquo;field1\u0026rsquo;, \u0026lsquo;field2\u0026rsquo;) Exists:\nThe exists method checks if there are any records in the queryset. Example:\nqueryset_exists = Model.objects.filter(field=value).exists() Update and Delete:\nThe update method modifies multiple records in the database without fetching them. The delete method deletes records from the database without fetching them. Example:\npython Copy code Model.objects.filter(field=value).update(status=\u0026lsquo;new_status\u0026rsquo;) Model.objects.filter(field=value).delete() These are just a few of the many properties and methods provided by Django querysets. They offer a powerful and expressive way to interact with the database.\nEsempio in wagtail from datetime import datetime, timedelta, timezone from django.shortcuts import render from wagtail.core.models import Page from your_app.models import RoundPage # Replace \u0026lsquo;your_app\u0026rsquo; with the actual name of your app from path.to.get_deadline_date_for import get_deadline_date_for # Replace \u0026lsquo;path.to\u0026rsquo; with the actual path\ndef docs_internship(request): now = datetime.now(timezone.utc) today = get_deadline_date_for(now) five_weeks_ago = today - timedelta(days=7 * 5)\napplicant_round = RoundPage.objects.filter( pingnew__lte=today, internannounce__gt=today, ).first() intern_round = RoundPage.objects.filter( internannounce__lte=today, internends__gt=five_weeks_ago, ).first() return render(request, 'home/docs/internship_guide.html', { 'applicant_round': applicant_round, 'intern_round': intern_round, }) GIT \u0026amp; GITHUB Riferimenti Mastering MarkDown\nRicordarsi di aggiungere .gitgnore - git add .gitignore - git commit -m \u0026ldquo;Add .gitignore to exclude compiled Python files\u0026rdquo;\nPer effettuare il push da origine a remoto - git push origin implementazione-pagina\nSwitch to the New Branch: - git checkout new-branch-name\nCreare una nuova branch e posizionarsi sulla stessa - git checkout -b new-branch-name Il comando può essere visto come la sintesi dei due seguenti comandi: - git branch new-branch-name # Create a new branch - git checkout new-branch-name # Switch to the new branch\nYou\u0026rsquo;ve created a new branch (template-tutorial) without committing changes on your existing branch (implementazione-pagina) To address this, you\u0026rsquo;ll need to follow these steps to commit your changes on the implementazione-pagina branch and then switch back to the template-tutorial branch. Here\u0026rsquo;s a step-by-step guide:\nCommit Changes on implementazione-pagina: Assuming you are currently on the template-tutorial branch, ** switch back to the implementazione-pagina branch:** git checkout implementazione-pagina\nNow, add and commit your changes:\ngit add . git commit -m \u0026quot;Your commit message here\u0026quot;\nPush Changes to Remote (implementazione-pagina): Assuming the remote branch is named implementazione-pagina: git push origin implementazione-pagina\n** Switch Back to template-tutorial:** Now, switch back to the template-tutorial branch: git checkout template-tutorial\n*** If you haven\u0026rsquo;t pushed the template-tutorial branch yet, you can push it to the remote repository when you\u0026rsquo;re ready:***\ngit push origin template-tutorial\n*** How can see from my vsc local if a git branch is present also in the remote github? ***\ngit fetch --all git branch -a This fetches all branches from the remote repository and lists both local and remote branches. Remote branches are prefixed with \u0026ldquo;remotes/origin/\u0026rdquo;. Check if your branch is listed among the remotes.\n*** Come posso creare una nuova branch in local, e poi crearla anche in Github, poi effettuare il push e rendere questa branch principale? ***\nCreate a new branch locally and switch to it (chimiamo la nuova branch template-tutorial): git checkout -b template-tutorial\nPush the new branch to GitHub - *** If you want to make sure that the new branch on GitHub exactly matches your local branch, you can use the -u (or \u0026ndash;set-upstream) option when pushing for the first time ***\ngit push -u origin template-tutorial\nSet the upstream for the new branch:\ngit branch --set-upstream-to=origin/template-tutorial template-tutorial![alt]( \u0026lsquo;{\u0026ldquo;class\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;title\u0026rdquo;: \u0026ldquo;\u0026rdquo;}\u0026rsquo;)\nNow, further pushes can be simplified to:\ngit push\nTo revert the changes and go back to the original commit before the changes, you can use the following commands: git reset --hard HEAD git clean -fd\nThe first command (git reset \u0026ndash;hard HEAD) resets your branch to the latest commit, discarding changes. The second command (git clean -fd) removes untracked files and directories. Use them with caution, as they are not reversible.\n-fd stands for what? In the context of the git clean command:\n-f stands for force. -d stands for directory. Together, -fd means force removal of untracked directories. This option is used to remove untracked files and directories forcefully.\ndelete a local branch and also delete it on the remote repository on GitHub Delete the local branch:\ngit branch -d branch_name![alt]( \u0026lsquo;{\u0026ldquo;class\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;title\u0026rdquo;: \u0026ldquo;\u0026rdquo;}\u0026rsquo;)\nReplace branch_name with the name of the branch you want to delete.\nIf the branch contains unmerged changes, you might need to force delete it:\ngit branch -D branch_name\nDelete the remote branch:\ngit push origin --delete branch_name\nThis will delete the branch on the remote repository (GitHub).\nUpdate your local repository to reflect the changes on the remote:\ngit fetch --prune\nThe \u0026ndash;prune flag removes any remote tracking branches that no longer exist on the remote.\nI want to synch another an oldest branch named \u0026ldquo;template-tutorial\u0026rdquo; with a newest branch named template-sheetlike and after delete this last one (template-sheetlike) Switch to the template-tutorial branch: git switch template-tutorial\nRebase template-sheetlike onto template-tutorial: git rebase template-sheetlike\nPush the changes to the remote repository: git push origin template-tutorial --force Note: Force-pushing after a rebase rewrites the commit history. Use it with caution, especially if the branch has already been shared with others\nDelete the template-sheetlike branch: git branch -d template-sheetlike git push origin --delete template-sheetlike\nsome useful notes Merge: Creates Merge Commits: When you merge one branch into another, Git creates a new merge commit that has two parent commits: one from the branch you\u0026rsquo;re merging and another from the branch you\u0026rsquo;re merging into. This results in a non-linear history with multiple branches merging into each other Preserves Original History:\nThe original commits from both branches remain unchanged. This approach keeps a clear record of when changes were made on each branch.\nRebase: Linearizes History:\nRebase is used to linearize the commit history. It moves or combines a sequence of commits to a new base commit. When you rebase one branch onto another, it effectively transplants the entire branch onto the tip of the other branch, creating a linear history. No Merge Commits:\nUnlike merge, rebase doesn\u0026rsquo;t create additional merge commits. It can result in a cleaner, more linear history. When to Choose Each Approach:\nMerge: Use merge when you want to preserve the original commit history, especially when collaborating with others. Good for feature branches and when you want to maintain a clear record of branch integration points. Rebase:\nUse rebase when you want a clean, linear history and don\u0026rsquo;t mind rewriting commits. Useful for feature branches before merging into a shared branch to avoid unnecessary merge commits. Switch vs. Checkout: git switch is a more modern and user-friendly command introduced in recent versions of Git. It is designed specifically for branch switching. If you\u0026rsquo;re using a version of Git that supports git switch, you can replace git checkout with git switch:\nSwitching Branch: git switch template-tutorial Both commands essentially do the same thing in this context, but git switch provides a clearer and more explicit syntax for branch-related operations. If your Git version supports it, feel free to use git switch instead of git checkout.\nYAML PROTOCOL YAML (YAML Ain\u0026rsquo;t Markup Language) is a human-readable data serialization format that is often used for configuration files and data exchange between languages with different data structures. In a YAML file, indentation is crucial, as it determines the structure of the data. Here are some details on writing YAML files:\n1. Indentation: YAML uses indentation to represent the structure of the data. Spaces are recommended for indentation (not tabs), and the number of spaces is significant. Typically, two spaces or four spaces are used for each level of indentation. codekey1: key2: value key3: - item1 - item2 2. Key-Value Pairs: YAML uses a simple key-value format. Keys and values are separated by a colon, and the key-value pair is represented on a new line. codename: John Doe age: 30 3. Lists: Lists are represented using a hyphen followed by a space (- ). Lists can contain any combination of values, and each item is indented under the list key. codefruits: - apple - banana - orange 4. Dictionaries (Mappings): Dictionaries or mappings are represented using key-value pairs, and the key-value pairs are indented under the dictionary key. name: John Doe age: 30 5. Strings: Strings can be written without quotes. However, quotes are used when a string contains special characters or reserved words. message: Hello, World! 6. Multiline Strings: Multiline strings can be represented using the | or \u0026gt; characters. The | preserves newlines, while \u0026gt; folds newlines. codemultiline: | This is a multiline string in YAML. 7. Comments: Comments start with the # character and continue to the end of the line. code# This is a comment key: value 8. Anchors and Aliases: YAML supports anchors (\u0026amp;) and aliases (*) for creating references to the same data in multiple places. codefirst: \u0026amp;anchor_name John Doe second: *anchor_name These are some basic conventions for writing YAML files. Ensure that you are consistent with indentation, use proper syntax for key-value pairs, lists, and dictionaries, and pay attention to the structure of your YAML documents. Many programming languages and tools use YAML, and understanding its syntax is beneficial for working with various configurations and data files.\nWAGTAIL How to use StreamField for mixed content StreamField block reference Templating - Jinja Wrinting Templates La regola da seguire è questa:\ncode: class wagtail.fields.StreamField(blocks, use_json_field=None, blank=False, min_num=None, max_num=None, block_counts=None, collapsed=False)\nE questa la spiegazione:\nclass wagtail.fields.StreamField: This line defines a class named StreamField in the wagtail.fields module.\n(blocks, use_json_field=None, blank=False, min_num=None, max_num=None, block_counts=None, collapsed=False): These are the parameters that the StreamField class constructor (init method) accepts. Let\u0026rsquo;s go through each one:\nblocks: This is a required parameter. It represents the blocks that can be used in the stream. It seems like it should be provided when creating an instance of StreamField.\nuse_json_field=None: This is an optional parameter with a default value of None. It allows you to specify whether to use a JSON field for storage. If not provided, it defaults to None.\nblank=False: This is an optional parameter with a default value of False. It indicates whether the field is allowed to be blank when used in a form. If not provided, it defaults to False.\nmin_num=None: This is an optional parameter with a default value of None. It specifies the minimum number of blocks required. If not provided, it defaults to None.\nmax_num=None: This is an optional parameter with a default value of None. It specifies the maximum number of blocks allowed. If not provided, it defaults to None.\nblock_counts=None: This is an optional parameter with a default value of None. It seems related to counting blocks. If not provided, it defaults to None.\ncollapsed=False: This is an optional parameter with a default value of False. It indicates whether the blocks should be collapsed in the Wagtail admin interface. If not provided, it defaults to False\nCosì ad esempio per questo codice. Possiamo effettuare il breakdown di questo codice in base alla regola definita:\n`class BlogPage(Page): author = models.CharField(max_length=255, default=\u0026lsquo;Default Author\u0026rsquo;) date = models.DateField(\u0026ldquo;Post date\u0026rdquo;)\nbody = StreamField( [ ('heading', blocks.CharBlock(form_classname=\u0026quot;title\u0026quot;)), ('paragraph', blocks.RichTextBlock()), ('image', ImageChooserBlock()), ('code', CodeBlock()), ('raw_html', RawHTMLBlock()), ], use_json_field=True ) content_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('body'), ] `\nauthor = models.CharField(max_length=255, default=\u0026lsquo;Default Author\u0026rsquo;): This line defines a character field named author in the BlogPage class. It has a maximum length of 255 characters and a default value of \u0026lsquo;Default Author\u0026rsquo;.\ndate = models.DateField(\u0026ldquo;Post date\u0026rdquo;): This line defines a date field named date in the BlogPage class with a human-readable name \u0026ldquo;Post date\u0026rdquo;.\nbody = StreamField([\u0026hellip;], use_json_field=True): This line defines a stream field named body in the BlogPage class. It allows the inclusion of different block types, such as CharBlock, RichTextBlock, ImageChooserBlock, CodeBlock, and RawHTMLBlock. The use_json_field parameter is set to True, indicating that a JSON field will be used for storage.\ncontent_panels = Page.content_panels + [\u0026hellip;]: This line defines the content panels for the Wagtail admin interface. It includes panels for \u0026lsquo;author\u0026rsquo;, \u0026lsquo;date\u0026rsquo;, and \u0026lsquo;body\u0026rsquo;.\nPoi in particolare:\ncontent_panels definition in the BlogPage class:#### content_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('body'), ]\nPage.content_panels: This part includes the content panels defined in the parent Page class. It allows the inclusion of standard page fields, such as title, slug, publish date, etc.\nFieldPanel(\u0026lsquo;author\u0026rsquo;): This adds a panel for the author field to the content panels. It\u0026rsquo;s likely a simple text input for the author\u0026rsquo;s name.\nFieldPanel(\u0026lsquo;date\u0026rsquo;): This adds a panel for the date field, probably a date picker for selecting the post date.\nFieldPanel(\u0026lsquo;body\u0026rsquo;): This adds a panel for the body field. Since it\u0026rsquo;s a StreamField, it might include a dynamic set of blocks like headings, paragraphs, images, code blocks, and raw HTML.\nUso dello StructBox in Wagtail Example Model with StructBlock Consider a simple model for a page with a StreamField containing a StructBlock named \u0026lsquo;person\u0026rsquo;:\n` # models.py from django.db import models from wagtail.core.fields import StreamField from wagtail.core import blocks from wagtail.images.blocks import ImageChooserBlock from wagtail.core.models import Page from wagtail.admin.edit_handlers import FieldPanel, StreamFieldPanel\nclass BlogPage(Page): body = StreamField([ (\u0026lsquo;person\u0026rsquo;, blocks.StructBlock([ (\u0026lsquo;first_name\u0026rsquo;, blocks.CharBlock()), (\u0026lsquo;surname\u0026rsquo;, blocks.CharBlock()), (\u0026lsquo;photo\u0026rsquo;, ImageChooserBlock(required=False)), (\u0026lsquo;biography\u0026rsquo;, blocks.RichTextBlock()), ])), (\u0026lsquo;heading\u0026rsquo;, blocks.CharBlock(form_classname=\u0026ldquo;title\u0026rdquo;)), (\u0026lsquo;paragraph\u0026rsquo;, blocks.RichTextBlock()), (\u0026lsquo;image\u0026rsquo;, ImageChooserBlock()), ], use_json_field=True)\ncontent_panels = Page.content_panels + [ StreamFieldPanel('body'), ] `\u0026lt;/span\u0026gt; Diagram Explanation Blog Page with StreamField and StructBlock:\nA BlogPage contains a StreamField named \u0026lsquo;body\u0026rsquo;. \u0026lsquo;body\u0026rsquo; includes various block types, one of which is a StructBlock named \u0026lsquo;person\u0026rsquo;. Person StructBlock:\nThe \u0026lsquo;person\u0026rsquo; block is a StructBlock containing fields like \u0026lsquo;first_name\u0026rsquo;, \u0026lsquo;surname\u0026rsquo;, \u0026lsquo;photo\u0026rsquo;, and \u0026lsquo;biography\u0026rsquo;. Block Instances:\nWhen editing a BlogPage, you can add multiple instances of different block types, including \u0026lsquo;person\u0026rsquo;. Each \u0026lsquo;person\u0026rsquo; block instance can have its own \u0026lsquo;first_name\u0026rsquo;, \u0026lsquo;surname\u0026rsquo;, \u0026lsquo;photo\u0026rsquo;, and \u0026lsquo;biography\u0026rsquo;\nTemplate Implementation\nTo render this in a template, you can use the following:\n`\u0026lt;!-- templates/blog_page.html --\u0026gt; {% extends \u0026#34;base.html\u0026#34; %} {% block content %} \u0026lt;article\u0026gt; {% for block in page.body %} {% if block.block_type == \u0026#39;person\u0026#39; %} \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; {% if block.value.photo %} {% image block.value.photo width-400 %} {% endif %} \u0026lt;h2\u0026gt;{{ block.value.first_name }} {{ block.value.surname }}\u0026lt;/h2\u0026gt; {{ block.value.biography }} \u0026lt;/div\u0026gt; {% else %} {# Rendering for other block types #} \u0026lt;section class=\u0026#34;{{ block.block_type }}\u0026#34;\u0026gt; {% include_block block %} \u0026lt;/section\u0026gt; {% endif %} {% endfor %} \u0026lt;/article\u0026gt; {% endblock %} Database Initialization\nWhen you run makemigrations and migrate after adding the StructBlock to your model, the necessary database tables and fields are created. The use_json_field=True parameter in the StreamField indicates that the data for the StreamField will be stored as JSON in the database.\nHere\u0026rsquo;s how you perform the migration:\nbash Copy code python manage.py makemigrations python manage.py migrate After migration, you can create or edit a BlogPage instance through the Wagtail admin interface. The StructBlock fields will be part of the form for each \u0026lsquo;person\u0026rsquo; block within the \u0026lsquo;body\u0026rsquo; StreamField.\nRiferimenti Rapidi Wagtail Caso Studio web page\nHow to use Streamfield for mixed content\nStreamFieldBlock Reference\nCaratteristiche avanzate di Diango - Wagtail Uno dei porblemi che si incontrano effettuando delle tabelle all\u0026rsquo;interno di wagtail ma in generale anche in Django è il caso pratico della renderizzazione degli headers di una tabella se si vogliono recuperare ad esempio i dati all\u0026rsquo;interno delle celle della tabella.\nAttenzione!: questo progetto è illustrato al solo fine didattico. Infatti nell\u0026rsquo;applicazione concreta vi sono notevoli problemi nell\u0026rsquo;effettuare il passaggio dei dati da Django a Wagtail. Per cui ai fini applicativi la via migliore per rendere i dati da Django a Wagtail è quella della costruzione di un API attraverso serializer (vedere capitolo)\nQuesto codice di esempio effettua il debug su ciò che è successo:\n` {% for column in block.value.columns %} {{ column.header|default:\u0026ldquo;Column Header\u0026rdquo; }}\n\u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: {{ block.value.rows|list }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: {{ block.value.rows|list.1|default:\u0026quot;\u0026quot; }}\u0026lt;/p\u0026gt; {% with block.value.rows|list.1|default:\u0026quot;\u0026quot; as row_values %} {{ row_values.0|default:\u0026quot;\u0026quot; }} {% endwith %} \u0026lt;/th\u0026gt; {% endfor %} \u0026lt;/tr\u0026gt; \u0026lt;th\u0026gt; Column Header \u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: \u0026amp;lt;generator object TypedTable.rows at 0x7f08958de2e0\u0026amp;gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: \u0026lt;/p\u0026gt; ` Approfondendo la ricerca si artriva a tale indicazione :::caution The issue seems to be related to the fact that block.value.rows is a generator object. In Python, generators are lazy and can be consumed only once. If you try to iterate through the generator more than once, you will get an empty result on subsequent iterations.\nIn your case, it seems like the generator has been consumed once, which is why when you try to access block.value.rows.1, it doesn\u0026rsquo;t contain any values.\nTo address this issue, you might want to convert the generator to a list so that you can iterate through it multiple times. However, since you are using the TypedTableBlock from wagtail.contrib.typed_table_block, you might need to adjust how you access the rows.\nHere is a modification that converts the generator to a list before using it:\ndjango Copy code\n\u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: {{ block.value.rows|list }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: {{ block.value.rows|list.1|default:\u0026quot;\u0026quot; }}\u0026lt;/p\u0026gt; {% with block.value.rows|list.1|default:\u0026quot;\u0026quot; as row_values %} {{ row_values.0|default:\u0026quot;\u0026quot; }} {% endwith %} \u0026lt;/th\u0026gt; {% endfor %} \u0026lt;/tr\u0026gt; HOW TO FEED A TABLE FROM DJANGO ADMIN PANEL, OPEN IN AS BLOCK INTO WAGTAIL ADMIN PANEL AND RENDER IT INTO THE WAGTAIL FRONTEND Premessa: prima di effettuare questa complessa operazione va tenuto in conto che i due progetti uno django e l\u0026rsquo;altro wagtail derivano da due repository differenti. Quindi il problema iniziale sarà quello di renedere omogenei i file .git. Per fare ciò dunque di seguito si descrive il metodo migliore individuato:\nIf you want to consolidate both the Django and Wagtail projects into a single Git repository, and you\u0026rsquo;ve already initialized separate repositories in each project\u0026rsquo;s directory, you have a couple of options:\nOption 1: Delete Existing Git Repositories\nDelete Git repositories in directory and subdirectories:\nNavigate to each subdirectory (e.g., django_general_template2 and blog_wiki_wag/blog_page_wiki_wag/wiki-wag) containing a Git repository. Run rm -rf .git to delete the existing Git repository. Initialize a new Git repository in the root directory:\nRun cd /path/to/django_general_template2 (replace /path/to/django_general_template2 with your actual path). Run git init to initialize a new Git repository. Add, commit, and push:\nAdd all files with git add .. Commit the changes with git commit -m \u0026quot;Initial commit\u0026quot;. If you\u0026rsquo;ve already set up a remote repository, push the changes to it. Great! Since you\u0026rsquo;ve deleted the existing Git repositories and initialized a new one in the root directory, here are the steps to create a new GitHub repository (django-wiki-wag) and push your local changes to it:\nCreate a New GitHub Repository:\nGo to GitHub. Log in to your account. Click the \u0026ldquo;+\u0026rdquo; icon in the top right corner and select \u0026ldquo;New repository.\u0026rdquo; Fill in the repository name (e.g., django-wiki-wag), add a description if you want, and choose other repository settings. Click \u0026ldquo;Create repository.\u0026rdquo; Set the Remote Origin for Your Local Repository:\nIn your local terminal, navigate to the root directory of your project.\nRun the following commands, replacing the repository URL with your newly created repository URL:\nbashCopy code git remote add origin https://github.com/your-username/django-wiki-wag.git Add, Commit, and Push:\nRun the following commands to add all files, commit your changes, and push to GitHub:\nbashCopy codegit add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin main Note: Replace main with the name of the branch you are working on (it could be master or another branch).\nVerify on GitHub:\nVisit your GitHub repository (https://github.com/your-username/django-wiki-wag). Confirm that your files and project structure are visible. Now, your local project should be synchronized with the new GitHub repository. If you encounter any issues during the process, feel free to ask for further assistance!\nTo achieve your goal, you\u0026rsquo;ll need to follow a series of steps. I\u0026rsquo;ll provide you with a step-by-step guide to make the necessary changes and additions to your Django admin, Wagtail models, and HTML template.\nStep 1: Adjust Wagtail Settings\nIn the settings.py of your Wagtail project (wiki-wag), ensure that the ALLOWED_HOSTS setting includes the appropriate values for your Django project. Update other settings if needed.\npythonCopy code# wiki-wag/settings/base.py ALLOWED_HOSTS = [\u0026#39;yourdjangoapp.com\u0026#39;, \u0026#39;localhost\u0026#39;, \u0026#39;127.0.0.1\u0026#39;] Step 2: Add Wagtail settings to Django settings.py\nIn your Django project (`general_template 1), include the Wagtail settings by updating settings.py:\n\u0026#34;\u0026#34;\u0026#34; Django settings for general_template1 project. Generated by \u0026#39;django-admin startproject\u0026#39; using Django 4.2.2. For more information on this file, see https://docs.djangoproject.com/en/4.2/topics/settings/ For the full list of settings and their values, see https://docs.djangoproject.com/en/4.2/ref/settings/ \u0026#34;\u0026#34;\u0026#34; from pathlib import Path # Build paths inside the project like this: BASE_DIR / \u0026#39;subdir\u0026#39;. BASE_DIR = Path(__file__).resolve().parent.parent # Quick-start development settings - unsuitable for production # See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/ # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY = \u0026#39;django-insecure-2-yc!0z!mcv#w$3vk6#s5i635l+bg#x3+24w2!26ikg4o-dj4u\u0026#39; # SECURITY WARNING: don\u0026#39;t run with debug turned on in production! DEBUG = True # ALLOWED_HOSTS = [\u0026#39;127.0.0.1\u0026#39;, \u0026#39;localhost\u0026#39;, \u0026#39;146.190.169.21\u0026#39;] # tiene conto delle attività su droplet ALLOWED_HOSTS = [\u0026#39;app.sgbh.org\u0026#39;, \u0026#39;www.sgbh.org\u0026#39;, \u0026#39;127.0.0.1\u0026#39;, \u0026#39;localhost\u0026#39;, \u0026#39;146.190.169.21\u0026#39;] SECURE_PROXY_SSL_HEADER = (\u0026#39;HTTP_X_FORWARDED_PROTO\u0026#39;, \u0026#39;https\u0026#39;) # Application definition INSTALLED_APPS = [ \u0026#39;wagtail.contrib.forms\u0026#39;, \u0026#39;wagtail.contrib.redirects\u0026#39;, \u0026#39;wagtail.embeds\u0026#39;, \u0026#39;wagtail.sites\u0026#39;, \u0026#39;wagtail.users\u0026#39;, \u0026#39;wagtail.snippets\u0026#39;, \u0026#39;wagtail.documents\u0026#39;, \u0026#39;wagtail.images\u0026#39;, \u0026#39;wagtail.search\u0026#39;, \u0026#39;wagtail.admin\u0026#39;, \u0026#39;taggit\u0026#39;, \u0026#39;modelcluster\u0026#39;, \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;sgq\u0026#39;, \u0026#39;wagtail\u0026#39;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, \u0026#39;wagtail.contrib.redirects.middleware.RedirectMiddleware\u0026#39;, ] ROOT_URLCONF = \u0026#39;general_template1.urls\u0026#39; TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] WSGI_APPLICATION = \u0026#39;general_template1.wsgi.application\u0026#39; WSGI_SERVER_PORT = 443 # Database # https://docs.djangoproject.com/en/4.2/ref/settings/#databases DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#39;db.sqlite3\u0026#39;, } } # Password validation # https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators AUTH_PASSWORD_VALIDATORS = [ { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.UserAttributeSimilarityValidator\u0026#39;, }, { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.MinimumLengthValidator\u0026#39;, }, { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.CommonPasswordValidator\u0026#39;, }, { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.NumericPasswordValidator\u0026#39;, }, ] # Internationalization # https://docs.djangoproject.com/en/4.2/topics/i18n/ LANGUAGE_CODE = \u0026#39;en-us\u0026#39; TIME_ZONE = \u0026#39;UTC\u0026#39; USE_I18N = True USE_TZ = True # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/4.2/howto/static-files/ STATIC_URL = \u0026#39;static/\u0026#39; # Default primary key field type # https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field DEFAULT_AUTO_FIELD = \u0026#39;django.db.models.BigAutoField\u0026#39; Step 3: Add Wagtail URLs to Django URLs\nIn your Django project (`general_template 1), include the Wagtail urls by updating urls.py:\nfrom django.contrib import admin from django.urls import path, include from wagtail import urls as wagtail_urls urlpatterns = [ path(\u0026#39;\u0026#39;, include(\u0026#39;sgq.urls\u0026#39;)), # Include the app-level URLs path(\u0026#39;admin/\u0026#39;, admin.site.urls), # path(\u0026#39;wagtail/\u0026#39;, include(\u0026#39;wagtail.core.urls\u0026#39;)), # nuovo inserimento path(\u0026#39;wagtail/\u0026#39;, include(wagtail_urls)), # nuovo inserimento ] **Step 4: Add a Fixed Table Block to Your Models **and Update BlogPage Model ** In your blog/models.py, add the FixedTableBlock to the list of available blocks. This block will represent the fixed table content. Include the FixedTableBlock in the StreamField of your BlogPage model.\nThe key changes here are adding the import for FixedTableBlock and including it in the StreamField under the name 'fixed_table'. from wagtail.images.blocks import ImageChooserBlock from wagtail.fields import StreamField, RichTextField from wagtail.admin.panels import FieldPanel from wagtail.documents.blocks import DocumentChooserBlock from wagtail.models import Page from wagtail import blocks from wagtail.contrib.table_block.blocks import TableBlock from wagtail.contrib.routable_page.models import RoutablePageMixin, path from django.db import models from wagtail.search import index from modelcluster.fields import ParentalKey from wagtail.contrib.forms.models import AbstractEmailForm, AbstractFormField from .blocks import PublicationBlock # rif 1 - Adding in rendering get_absolute_url from wagtail.contrib.typed_table_block.blocks import TypedTableBlock from wagtail.images.blocks import ImageChooserBlock class RawHTMLBlock(blocks.RawHTMLBlock): class Meta: icon = \u0026#34;code\u0026#34; # Set a suitable icon from available Wagtail icons template = \u0026#39;blog/raw_html_block.html\u0026#39; class CodeBlock(blocks.StructBlock): code = blocks.TextBlock() class Meta: template = \u0026#39;blog/code_block.html\u0026#39; class FixedTableBlock(blocks.StructBlock): fixed_table_text = blocks.CharBlock() class Meta: icon = \u0026#39;table\u0026#39; # Set an icon for the block template = \u0026#39;blog/fixed_table_block.html\u0026#39; # Create this template for rendering the block class BlogPage(Page): author = models.CharField(max_length=255, default=\u0026#39;Default Author\u0026#39;) date = models.DateField(\u0026#34;Post date\u0026#34;) # New field for content choice content_choice = models.CharField( max_length=20, choices=[ (\u0026#39;choice_one\u0026#39;, \u0026#39;Choice One\u0026#39;), (\u0026#39;choice_two\u0026#39;, \u0026#39;Choice Two\u0026#39;), ], default=\u0026#39;choice_one\u0026#39;, # Set a default choice help_text=\u0026#34;Select the content to be displayed on the page.\u0026#34; ) body = StreamField([ (\u0026#39;heading\u0026#39;, blocks.CharBlock(form_classname=\u0026#34;title\u0026#34;)), (\u0026#39;paragraph\u0026#39;, blocks.RichTextBlock()), (\u0026#39;image\u0026#39;, ImageChooserBlock()), (\u0026#39;code\u0026#39;, CodeBlock()), (\u0026#39;raw_html\u0026#39;, RawHTMLBlock()), (\u0026#39;publication\u0026#39;, PublicationBlock()), # rif 1 - Adding in rendering get_absolute_url (\u0026#39;table\u0026#39;, TypedTableBlock([ (\u0026#39;text\u0026#39;, blocks.CharBlock()), (\u0026#39;numeric\u0026#39;, blocks.FloatBlock()), (\u0026#39;rich_text\u0026#39;, blocks.RichTextBlock()), (\u0026#39;image\u0026#39;, ImageChooserBlock()), (\u0026#39;country\u0026#39;, blocks.ChoiceBlock(choices=[ (\u0026#39;be\u0026#39;, \u0026#39;Belgium\u0026#39;), (\u0026#39;fr\u0026#39;, \u0026#39;France\u0026#39;), (\u0026#39;de\u0026#39;, \u0026#39;Germany\u0026#39;), (\u0026#39;nl\u0026#39;, \u0026#39;Netherlands\u0026#39;), (\u0026#39;pl\u0026#39;, \u0026#39;Poland\u0026#39;), (\u0026#39;uk\u0026#39;, \u0026#39;United Kingdom\u0026#39;), ])), ])), (\u0026#39;fixed_table\u0026#39;, FixedTableBlock()), # Add the FixedTableBlock ], use_json_field=True) content_panels = Page.content_panels + [ FieldPanel(\u0026#39;author\u0026#39;), FieldPanel(\u0026#39;date\u0026#39;), FieldPanel(\u0026#39;content_choice\u0026#39;), FieldPanel(\u0026#39;body\u0026#39;), ] **Step 5: **Go in the Wagtail manage.py level and make sure to run migrations after making these changes:\npython3 manage.py makemigrations python3 manage.py migrate Now you can use the Wagtail admin to add and edit the content for the fixed_table block in your BlogPage. This content should then be rendered in your blog_page.html\nAt this stage you go into Wagtail Project via **python3 manage.py runserver ** into admin panel and if all works you can access and add the table. In the wagtail preview mode you receive a visualization error because the blog/fixed_table_block.html does not exists!\nStep 6 - Creation of blog/fixed_table_block.html\nSo before to jump to Django admin level to create an input data entry let\u0026rsquo;s try to enter the data from FixedTableBlock(). In this manner sure that all is working fine just until now. To do this First, update the FixedTableBlock in models.py:\npythonCopy codefrom wagtail.core import blocks class FixedTableBlock(blocks.StructBlock): nation = blocks.CharBlock(required=True, help_text=\u0026#39;Enter nation\u0026#39;) capital = blocks.CharBlock(required=True, help_text=\u0026#39;Enter capital\u0026#39;) class Meta: template = \u0026#39;blog/fixed_table_block.html\u0026#39; Then, create or update the template file at blog/templates/blog/fixed_table_block.html:\nhtmlCopy code\u0026lt;div\u0026gt; \u0026lt;table class=\u0026#34;table table-bordered table-striped\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Nation\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Capital\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;{{ value.nation }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ value.capital }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; Go in the Wagtail manage.py level and make sure to run migrations after making these changes:\npython3 manage.py makemigrations python3 manage.py migrate python3 manage.py migrate If all works you are able to input the data and see the table in Wagtail preview mode\nAlways remeber to conslidate you commmit pushing on Github\nStep 7 - Implementation models.py - Django side\nCreate a Django model for the content you want to manage:\nDefine a Django model in your models.py that represents the content you want to associate with the FixedTableBlock\npythonCopy code# models.py from django.db import models class FixedTableContent(models.Model): nation = models.CharField(max_length=255) capital = models.CharField(max_length=255) def __str__(self): return self.nation Step 8 - Implementation admin.py - Django side\nCreate an admin class for the new model:\nCreate an admin class for your new model in the admin.py file:\n# admin.py from django.contrib import admin from .models import FixedTableContent @admin.register(FixedTableContent) class FixedTableContentAdmin(admin.ModelAdmin): list_display = (\u0026#39;nation\u0026#39;, \u0026#39;capital\u0026#39;) This admin class will allow you to manage instances of FixedTableContent in the Django admin.\n\u0026mdash;\u0026mdash;\u0026mdash; FINO A QUI \u0026ndash;\ntemplate.Step 3: Create Template for FixedTableBlock Create a template file at blog/templates/blog/fixed_table_block.html for rendering the FixedTableBlock. This template will be used to display the fixed table content.\nhtml Copy code {{ value.fixed_table_text }} Step 4: Run Migrations Run the following commands to apply the model changes:\nbash Copy code python manage.py makemigrations python manage.py migrate Step 5: Update Django Admin Create an admin class for BlogPage in blog/wagtail_hooks.py:\npython Copy code from wagtail.contrib.modeladmin.options import ( ModelAdmin, modeladmin_register, ModelAdminGroup ) from .models import BlogPage\nclass BlogPageAdmin(ModelAdmin): model = BlogPage menu_label = \u0026lsquo;Blog Pages\u0026rsquo; menu_icon = \u0026lsquo;doc-full-inverse\u0026rsquo; menu_order = 200 add_to_settings_menu = False exclude_from_explorer = False list_display = (\u0026rsquo;title\u0026rsquo;, \u0026lsquo;author\u0026rsquo;, \u0026lsquo;date\u0026rsquo;, \u0026lsquo;content_choice\u0026rsquo;) search_fields = (\u0026rsquo;title\u0026rsquo;, \u0026lsquo;author\u0026rsquo;, \u0026lsquo;date\u0026rsquo;, \u0026lsquo;content_choice\u0026rsquo;)\nmodeladmin_register(BlogPageAdmin) Step 6: Include Admin CSS In your blog/static/css/admin.css file, add the following CSS to improve the display of the custom block in the admin.\ncss Copy code .wagtail-edit-handler-fixed_table .field-content textarea { height: 100px; /* Adjust the height as needed */ } Step 7: Update BlogPage Admin Panels Update the content_panels in BlogPage to include the new block:\npython Copy code\n\u0026hellip; class BlogPage(Page): # \u0026hellip;\ncontent_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('content_choice'), FieldPanel('body'), ] Step 8: Update blog_page.html Update blog/templates/blog/blog_page.html to render the new FixedTableBlock.\nhtml Copy code\n{% for block in page.body %} {% if block.block_type == \u0026lsquo;fixed_table\u0026rsquo; %} {% include_block block %} {% elif block.block_type == \u0026rsquo;table\u0026rsquo; %} {% elif block.block_type == \u0026lsquo;heading\u0026rsquo; %} {% elif block.block_type == \u0026lsquo;publication\u0026rsquo; %} {% else %} {% endif %} {% endfor %}\nStep 9: Restart Server Restart your development server to see the changes:\nbash Copy code python manage.py runserver Now you should be able to add and edit the fixed table content in the Django admin and see it rendered on your blog_page.html. Adjust the styles and templates according to your design preferences.\nThis guide assumes a basic project structure, so adjust the paths if your project structure is different. Let me know if you have any questions or if there\u0026rsquo;s anything specific you\u0026rsquo;d like to clarify!\nWAGTAIL Upgrade process We recommend upgrading one feature release at a time, even if your project is several versions behind the current one. This has a number of advantages over skipping directly to the newest release:\nIf anything breaks as a result of the upgrade, you will know which version caused it, and will be able to troubleshoot accordingly;\nDeprecation warnings shown in the console output will notify you of any code changes you need to make before upgrading to the following version;\nSome releases make database schema changes that need to be reflected on your project by running ./manage.py makemigrations - this is liable to fail if too many schema changes happen in one go.\nBefore upgrading to a new feature release:\nCheck your project’s console output for any deprecation warnings, and fix them where necessary;\nCheck the new version’s release notes, and the Compatible Django / Python versions table below, for any dependencies that need upgrading first;\nMake a backup of your database.\nTo upgrade:\nUpdate the wagtail line in your project’s requirements.txt file to specify the latest patch release of the version you wish to install. For example, to upgrade to version 1.8.x, the line should read: `wagtail\u0026gt;=1.8,\u0026lt;1.9 Run:\npip install -r requirements.txt ./manage.py makemigrations ./manage.py migrate`\nMake any necessary code changes as directed in the “Upgrade considerations” section of the release notes.\nTest that your project is working as expected.\nRemember that the JavaScript and CSS files used in the Wagtail admin may have changed between releases - if you encounter erratic behaviour on upgrading, ensure that you have cleared your browser cache. When deploying the upgrade to a production server, be sure to run ./manage.py collectstatic to make the updated static files available to the web server. In production, we recommend enabling ManifestStaticFilesStorage in the STATICFILES_STORAGE setting - this ensures that different versions of files are assigned distinct URLs.\nFEEDING DATA FROM DJANGO TO WAGATAIL VIA API Steps:\nTo create a Django API app and expose the data to your Wagtail project, you can follow these steps:\nStep 1: Create Django API App (create a Django app from 0) Open your terminal and navigate to the root directory of your Django project.\nRun the following command to create a new Django app for your API:\npython manage.py startapp django_api_for_wagtail Install the Django REST framework to use it in your Django API app. Django REST framework is a powerful and flexible toolkit for building Web APIs in Django.\nYou can install it using pip. Open your terminal and navigate to your project\u0026rsquo;s root directory. Then, run the following command:\npip3 install djangorestframework After installing, you\u0026rsquo;ll need to add 'rest_framework' to the INSTALLED_APPS in your project\u0026rsquo;s settings.py:\n# myproject/settings.py INSTALLED_APPS = [ # ... \u0026#39;rest_framework\u0026#39;, # ... ] Now that you have a separate app named django_api_for_wagtail for the purpose, let\u0026rsquo;s create a data input example. Assuming you\u0026rsquo;ve created your Nation model within this app, here are the corrected steps:\nDjango API (Django Side): models.py in django_api_for_wagtail app: # django_api_for_wagtail/models.py from django.db import models class Nation(models.Model): name = models.CharField(max_length=255, unique=True) capital = models.CharField(max_length=255) def __str__(self): return self.name serializers.py in django_api_for_wagtail app: # django_api_for_wagtail/serializers.py from rest_framework import serializers from .models import Nation class NationSerializer(serializers.ModelSerializer): class Meta: model = Nation fields = \u0026#39;__all__\u0026#39; views.py in django_api_for_wagtail app: #django_api_for_wagtail/views.py from rest_framework import generics from .models import Nation from .serializers import NationSerializer class NationAPIView(generics.ListCreateAPIView): queryset = Nation.objects.all() serializer_class = NationSerializer urls.py in django_api_for_wagtail app: # django_api_for_wagtail/urls.py from django.urls import path from .views import NationAPIView urlpatterns = [ path(\u0026#39;nations/\u0026#39;, NationAPIView.as_view(), name=\u0026#39;nation-api\u0026#39;), # Add more URL patterns as needed ] admin.py in django_api_for_wagtail app: Here\u0026rsquo;s an example of how you should register the Nation model in the admin.py file:\n# django_api_for_wagtail/admin.py from django.contrib import admin from .models import Nation @admin.register(Nation) class NationAdmin(admin.ModelAdmin): list_display = (\u0026#39;name\u0026#39;, \u0026#39;capital\u0026#39;) urls.py in progetto_api project: To make Django recognize the URLs of your django_api_for_wagtail app, you need to include the URLs of your app in the urls.py file at the project level. You can do this using Django’s include() function, which allows you to reference other URL configurations.\nHere’s how you might update your urls.py file at the project level:Python\nfrom django.contrib import admin from django.urls import include, path urlpatterns = [ path(\u0026#34;admin/\u0026#34;, admin.site.urls), path(\u0026#34;django_api_for_wagtail/\u0026#34;, include(\u0026#39;django_api_for_wagtail.urls\u0026#39;)), ] Test if the steps are correct python3 manage.py makemigrations python3 manage.py migrate If all is ok you can try:\nhttp://127.0.0.1:8000/django_api_for_wagtail/nations/ (frontend side - with json results)\nhttp://127.0.0.1:8000/admin/django_api_for_wagtail/nation/ (backend side - with admin panel)\nIn this way, I can verify the correct data entry on the backend side and the correct management in JSON on the frontend side.\nStep 2: Create Views for API In the api app directory, create a views.py file.\nDefine a view for your API in views.py. For example:\nfrom rest_framework import generics from blog.models import BlogPage from .serializers import BlogPageSerializer class BlogPageAPIView(generics.ListAPIView): queryset = BlogPage.objects.all() serializer_class = BlogPageSerializer Step 3: Configure URLs for API In the api app directory, create a urls.py file.\nDefine the URL patterns for your API in urls.py. For example:\nfrom django.urls import path from .views import BlogPageAPIView urlpatterns = [ path(\u0026#39;blog/\u0026#39;, BlogPageAPIView.as_view(), name=\u0026#39;blog-api\u0026#39;), # Add more URL patterns as needed ] Step 4: Configure Main Project URLs In the main project directory, open the urls.py file.\nInclude the URLs of your API app in the project\u0026rsquo;s URL configuration. Update the urlpatterns:\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;api/\u0026#39;, include(\u0026#39;api.urls\u0026#39;)), # Adjust the URL pattern as needed # Add other URL patterns as needed ] Step 5: Run Migrations and Start the Development Server Run the following commands to apply migrations and start the development server:\nmanage.py makemigrations python manage.py migrate python manage.py runserver Definitive Code for mini Django project API Step 6: create the a frontend (to see the data ) To create a simple frontend to visualize the results from your Django API, you can use Django\u0026rsquo;s built-in templates. Here\u0026rsquo;s a step-by-step guide:\nCreate a templates directory within your django_api_for_wagtail app.\nInside the templates directory, create an HTML file for rendering the nation data. Let\u0026rsquo;s call it nations_list.html.\n\u0026lt;!-- django_api_for_wagtail/templates/nations_list.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Nations List\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Nations List\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {% for nation in nations %} \u0026lt;li\u0026gt;{{ nation.name }} - {{ nation.capital }}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Update your views.py to use this template:\n# django_api_for_wagtail/views.py from django.shortcuts import render from rest_framework import generics from .models import Nation from .serializers import NationSerializer class NationAPIView(generics.ListCreateAPIView): queryset = Nation.objects.all() serializer_class = NationSerializer def list(self, request, *args, **kwargs): nations = self.get_queryset() return render(request, \u0026#39;nations_list.html\u0026#39;, {\u0026#39;nations\u0026#39;: nations}) It is worth to breakdown the code above:\nLet\u0026rsquo;s break down the list method in the NationAPIView class:\n# django_api_for_wagtail/views.py from django.shortcuts import render from rest_framework import generics from .models import Nation from .serializers import NationSerializer class NationAPIView(generics.ListCreateAPIView): queryset = Nation.objects.all() serializer_class = NationSerializer def list(self, request, *args, **kwargs): nations = self.get_queryset() return render(request, \u0026#39;nations_list.html\u0026#39;, {\u0026#39;nations\u0026#39;: nations}) queryset and serializer_class: These are attributes of the NationAPIView class. queryset defines the initial query set of nations, and serializer_class specifies the serializer to be used for serializing the data. list method: This method is part of the ListCreateAPIView class provided by Django REST Framework. It handles the HTTP GET request for the list view. self.get_queryset(): This method retrieves the query set of nations. In this case, it gets all the objects from the Nation model specified in the queryset attribute. render function: This function is used to render an HTML template. It takes the following parameters: request: The HTTP request object. 'nations_list.html': The name of the template file to be rendered. {'nations': nations}: A dictionary containing data to be passed to the template. In this case, it includes the retrieved nations from the query set. return render(...): This line returns the rendered HTML content as an HTTP response. The rendered content will be the result of applying the data from the nations query set to the \u0026rsquo;nations_list.html\u0026rsquo; template. In summary, when a user accesses the URL associated with the NationAPIView, the list method is called. It retrieves the list of nations, passes them to the \u0026rsquo;nations_list.html\u0026rsquo; template, renders the HTML content, and returns it as an HTTP response. This allows you to view a list of nations in a web browser when accessing the corresponding URL.\nLet\u0026rsquo;s break down the list method in more detail:\nlist(self, request, *args, **kwargs): nations = self.get_queryset() return render(request, \u0026#39;nations_list.html\u0026#39;, {\u0026#39;nations\u0026#39;: nations}) self: In Python, self is a convention for referring to the instance of the class. In this context, it represents an instance of the NationAPIView class.\nrequest: This is the HTTP request object that is passed to the view. It contains information about the incoming request, such as the method (GET, POST, etc.), headers, and any data sent in the request.\n\\*args and \\**kwargs: These are used to collect additional positional and keyword arguments. In this case, they are not used in the method body, but the method signature includes them to allow flexibility.The usage of *args and **kwargs provides flexibility when defining functions or methods that can accept a variable number of arguments.\nUsing \\*args for Variable Positional Arguments: example_function(*args): for arg in args: print(arg) example_function(1, 2, 3, \u0026#39;four\u0026#39;) In this example, *args allows the function to accept any number of positional arguments. It collects them into a tuple named args, and the function can iterate over them.\nUsing \\**kwargs for Variable Keyword Arguments:\nexample_function(**kwargs): for key, value in kwargs.items(): print(f\u0026#34;{key}: {value}\u0026#34;) example_function(name=\u0026#39;John\u0026#39;, age=25, city=\u0026#39;New York\u0026#39;) In this example, **kwargs allows the function to accept any number of keyword arguments. It collects them into a dictionary named kwargs, and the function can iterate over the key-value pairs.\nCombining \\*args and \\**kwargs:\nexample_function(arg1, arg2, *args, **kwargs): print(f\u0026#34;arg1: {arg1}\u0026#34;) print(f\u0026#34;arg2: {arg2}\u0026#34;) print(f\u0026#34;Additional positional arguments: {args}\u0026#34;) print(f\u0026#34;Additional keyword arguments: {kwargs}\u0026#34;) example_function(1, 2, 3, 4, key1=\u0026#39;value1\u0026#39;, key2=\u0026#39;value2\u0026#39;) In this example, arg1 and arg2 are regular positional arguments, *args collects additional positional arguments into a tuple, and **kwargs collects additional keyword arguments into a dictionary.\nUsing *args and **kwargs allows a function or method to be more flexible and accommodate a varying number of arguments without explicitly specifying them in the function signature. This is particularly useful in cases where the number of arguments might change or when writing functions that need to work with a wide range of inputs.\nself.get_queryset(): This method is inherited from the ListCreateAPIView class of Django REST Framework. It retrieves the queryset of nations. The get_queryset method is responsible for returning the list of objects that will be used in the view.\nnations: This variable stores the queryset of nations obtained from self.get_queryset().\nrender(request, 'nations_list.html', {'nations': nations}): The render function is a shortcut provided by Django for rendering an HTML template. It takes the following arguments:\nrequest: The HTTP request object. 'nations_list.html': The name of the HTML template file to be rendered. {'nations': nations}: A dictionary containing data to be passed to the template. In this case, it includes the list of nations obtained from the queryset. return render(...): This line returns the rendered HTML content as an HTTP response. The rendered content will be the result of applying the data from the nations queryset to the \u0026rsquo;nations_list.html\u0026rsquo; template. In summary, the list method is responsible for retrieving a queryset of nations and rendering an HTML template (\u0026rsquo;nations_list.html\u0026rsquo;) with the nations\u0026rsquo; data. The rendered HTML content is then returned as an HTTP response. This is a common pattern for providing a list view in a Django REST Framework API.\nUpdate your urls.py to include a URL pattern for rendering the nations list: # django_api_for_wagtail/urls.py from django.urls import path from .views import NationAPIView urlpatterns = [ path(\u0026#39;nations/\u0026#39;, NationAPIView.as_view(), name=\u0026#39;nation-api\u0026#39;), path(\u0026#39;nations/list/\u0026#39;, NationAPIView.as_view(), name=\u0026#39;nations-list\u0026#39;), # Add more URL patterns as needed ] Finally, update your urls.py at the project level to include the django_api_for_wagtail URLs:\n# progetto_api/urls.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;django_api_for_wagtail/\u0026#39;, include(\u0026#39;django_api_for_wagtail.urls\u0026#39;)), ] Now, when you visit the URL http://127.0.0.1:8000/django_api_for_wagtail/nations/list/, it should render the nations list using the template.\nFino a qui\nStep 6: Access the API Open your web browser and navigate to http://127.0.0.1:8000/api/blog/ (or the URL you configured). You should see the serialized data from your Wagtail model. Step 7: Integrate with Wagtail In your Wagtail project, you can now fetch data from the API endpoint (http://127.0.0.1:8000/api/blog/) using Django\u0026rsquo;s requests library or any other method you prefer. Use the retrieved data to populate your Wagtail views/templates as needed. This is a basic setup, and you may need to customize it based on your specific requirements. Additionally, you might want to add authentication and permission controls to secure your API.\nWAGTAIL COMPATIBILITY WITH DJANGO ## - link PYTHON Spiegazione attraverso codice di init, getattribute e super Spesso nei moduli di wagtail si fa riferimento alla classazione e subclassazione. Avere chiri alcuni termini è necessario. Questa è la breve sintesi attraverso un sempio\nclass Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;)` This is a simple class representing a vehicle with a brand. It has an init method that initializes the brand attribute and a start method to print a message when the vehicle starts. Car (inherits from Vehicle):\npython Copy code class Car(Vehicle): def init(self, brand, model): # No use of super() self.model = model\ndef start(self): print(f\u0026quot;{self.brand} {self.model} car started.\u0026quot;) This class represents a specific type of vehicle, a Car, inheriting from the Vehicle class. It has its own init method, but it doesn\u0026rsquo;t use super(), and it has a start method that overrides the start method in the Vehicle class. CarWithSuper (inherits from Car):\nclass CarWithSuper(Car): def init(self, brand, model, color): super().init(brand, model) self.color = color\ndef start(self): super().start() print(f\u0026quot;The {self.color} car is ready to go.\u0026quot;) def __getattribute__(self, name): # Modifying __getattribute__ to add a prefix to the brand attribute if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__(name) else: return super().__getattribute__(name) This class inherits from Car and introduces a new attribute color. It uses super() in the init method to call the init method of the parent class (Car). It overrides the start method, calls the parent\u0026rsquo;s start method using super(), and adds an additional message. It also modifies getattribute to add a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the brand attribute. Examples: Example without super(), init, and getattribute:\ncar_without_super = Car(brand=\u0026quot;Toyota\u0026quot;, model=\u0026quot;Camry\u0026quot;) print(car_without_super.model) # Output: Camry An instance of Car is created without using super(). __init__ in Car is called, but __init__ of the parent (Vehicle) is not called. start method from Vehicle is not available in car_without_super. Example with super(), __init__, and __getattribute__: car_with_super = CarWithSuper(brand=\u0026quot;Ford\u0026quot;, model=\u0026quot;Mustang\u0026quot;, color=\u0026quot;red\u0026quot;) print(car_with_super.brand) # Output: Awesome Ford car_with_super.start() # Output: Ford Mustang car started. The red car is ready to go.\nAn instance of CarWithSuper is created using super() to call init of the parent (Car). getattribute is modified to add a prefix to the brand attribute. start method calls the parent\u0026rsquo;s (Car) start method using super() and adds an additional message. Roles:\ninit: Used for initializing the attributes of an object. In the inheritance chain, it\u0026rsquo;s common to use super().init(\u0026hellip;) to call the initializer of the parent class.\ngetattribute: Called whenever an attribute of an object is accessed. Can be modified to customize attribute access. Used here to modify the behavior of accessing the brand attribute.\nsuper(): Used to refer to the parent class. In init, it\u0026rsquo;s used to call the initializer of the parent class. In methods, it\u0026rsquo;s used to call methods from the parent class. In the provided example, super() helps maintain the hierarchy in inheritance, ensuring that the methods of the parent classes are appropriately called. init is used for object initialization, and getattribute is modified to customize attribute access.\nVediamo ora cosa succede se non utilizziamo i metodi Assenza di init If you don\u0026rsquo;t use the init method in the Vehicle class, the class will still be valid, but instances of the class won\u0026rsquo;t have a constructor to initialize their state. The init method is a special method in Python classes that is automatically called when an object is created. It is used for initializing the attributes of the object.\nHere\u0026rsquo;s what happens when you don\u0026rsquo;t include init:\npython Copy code class Vehicle: def start(self): print(\u0026ldquo;Vehicle started.\u0026rdquo;)\nCreating an instance without init vehicle_instance = Vehicle()\nThis will not raise an error, but the instance won\u0026rsquo;t have a \u0026lsquo;brand\u0026rsquo; attribute. If you try to access \u0026lsquo;brand\u0026rsquo;, it will result in an AttributeError. print(vehicle_instance.start()) # Output: Vehicle started. print(vehicle_instance.brand) # AttributeError: \u0026lsquo;Vehicle\u0026rsquo; object has no attribute \u0026lsquo;brand\u0026rsquo; In the example above, creating an instance of Vehicle without an init method is allowed. However, without an init method, instances won\u0026rsquo;t have any attributes initialized during instantiation. If you try to access an attribute that hasn\u0026rsquo;t been defined, you will get an AttributeError.\nIncluding the init method allows you to initialize the state of an object when it is created. For example:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) Creating an instance with init vehicle_instance = Vehicle(brand=\u0026ldquo;Toyota\u0026rdquo;)\nNow, the \u0026lsquo;brand\u0026rsquo; attribute is initialized during instantiation. print(vehicle_instance.start()) # Output: Toyota vehicle started. print(vehicle_instance.brand) # Output: Toyota In the second example, the init method is used to initialize the brand attribute when a Vehicle instance is created. This ensures that the instance has a properly initialized state from the beginning.\nEd ora quando posso usare e non usare getattribute?### If you don\u0026rsquo;t define the getattribute method in a class, Python will use the default behavior for attribute access. The default behavior involves looking up the attribute in the object\u0026rsquo;s dictionary and returning its value if found. If the attribute is not found in the object\u0026rsquo;s dictionary, Python looks for the attribute in the class hierarchy.\nHere\u0026rsquo;s what happens if you don\u0026rsquo;t use getattribute:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) Creating an instance without getattribute vehicle_instance = Vehicle(brand=\u0026ldquo;Toyota\u0026rdquo;)\nAccessing the \u0026lsquo;brand\u0026rsquo; attribute without a custom getattribute print(vehicle_instance.brand) # Output: Toyota\nThe default behavior is used, and there is no need for a custom getattribute in this case. In the example above, we create a Vehicle class with an init method to initialize the brand attribute. When we access the brand attribute, the default attribute access behavior is used, and there is no need for a custom getattribute. The attribute is found in the instance\u0026rsquo;s dictionary, and its value is returned.\nThe getattribute method is a powerful tool for customizing attribute access, and it allows you to intercept attribute access calls and customize the behavior. However, in many cases, you may not need to override it, and the default behavior is sufficient for basic attribute access. Only when you need to customize the attribute access behavior should you consider defining a getattribute method.\nIn the example provided, the getattribute method is used to customize the behavior of accessing the brand attribute in the CarWithSuper class. Specifically, it adds a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the value of the brand attribute before returning it.\nHere\u0026rsquo;s the relevant part of the code:\npython Copy code class CarWithSuper(Car): # \u0026hellip;\ndef __getattribute__(self, name): # Modifying __getattribute__ to add a prefix to the brand attribute if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__(name) else: return super().__getattribute__(name) In this case, the getattribute method is modifying the behavior of accessing the brand attribute. Without this customization, accessing car_with_super.brand would simply return the value of the brand attribute. With the custom getattribute, it returns the value with the added prefix.\nSo, you might need to use getattribute when you want to customize or intercept attribute access calls and modify the behavior based on your specific requirements. It\u0026rsquo;s a powerful tool, but it should be used judiciously, as unnecessary or incorrect use may lead to unexpected behavior and potential issues.\nMIXIN L\u0026rsquo;esempio esposto e che di seguito si ripropone risulta anche un ottimo esempio di mixin\nYes, the provided example with Vehicle, Car, and CarWithSuper can be considered an example of mixin-like behavior. Let me break it down:\nVehicle Class:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) This is the base class representing a generic vehicle. It has an init method to initialize the brand attribute and a start method.\nCar Class (Inherits from Vehicle):\npython Copy code class Car(Vehicle): def init(self, brand, model): super().init(brand) self.model = model\ndef start(self): print(f\u0026quot;{self.brand} {self.model} car started.\u0026quot;) The Car class inherits from Vehicle. It has its own init method but uses super() to call the init method of the parent class (Vehicle). It also has its own start method, overriding the start method of Vehicle.\nCarWithSuper Class (Inherits from Car):\npython Copy code class CarWithSuper(Car): def init(self, brand, model, color): super().init(brand, model) self.color = color\ndef start(self): super().start() print(f\u0026quot;The {self.color} car is ready to go.\u0026quot;) def __getattribute__(self, name): if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__('brand') else: return super().__getattribute__(name) The CarWithSuper class inherits from Car and introduces a new attribute (color). It uses super() to call the init method of the parent class (Car). It also overrides the start method, calling the parent\u0026rsquo;s (Car) start method using super() and adding an additional message. Additionally, it modifies getattribute to add a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the brand attribute.\nSo, in this example, the classes are organized in a way that exhibits mixin-like behavior. The CarWithSuper class enhances the behavior of the Car class by adding attributes and modifying methods, and it uses super() to maintain the hierarchy and call methods from parent classes. While it may not strictly adhere to the classic definition of a mixin, it shares some characteristics of mixin-like behavior.\nDefinizione di mixin In object-oriented programming, a mixin is a class that provides a certain functionality to be inherited by a subclass, but is not meant to stand alone. Mixins are used to enhance the functionality of a class without the need for multiple inheritance.\nHere are some key characteristics and features of mixins:\nPurpose-Specific Functionality: Mixins are designed to provide a specific set of functionalities or behaviors that can be easily added to other classes. They encapsulate a piece of behavior.\nReusability: Mixins promote code reuse. Instead of duplicating code in multiple classes, you can create a mixin and include it in various classes that need that particular behavior.\nNo Standalone Use: Mixins are not meant to be instantiated or used independently. They lack the complete implementation to be used as standalone classes. They are intended to be combined with other classes.\nFlexible Composition: Since a class can inherit from multiple mixins, it allows for flexible composition of functionalities. This is in contrast to languages that do not support multiple inheritance directly.\nAvoids Diamond Problem: Mixins can help avoid the \u0026ldquo;diamond problem\u0026rdquo; that arises in languages with multiple inheritance, where a class inherits from two classes that have a common ancestor.\nSmall and Focused: Mixins are typically small and focused on a specific task. This makes them easy to understand, maintain, and reuse.\nSTANDARD COMMANDS IN DJANGO INSTALLATION# python3 -m venv venv USEFUL PROPERTY AND METHOD IN DJANGO L\u0026rsquo;uso di Queryset Django querysets have several notable properties and methods that provide flexibility and ease of use when interacting with the database. Here are some key properties and methods of querysets:\nChaining:\nQuerysets are lazy, meaning they don\u0026rsquo;t hit the database until an action is performed. Multiple filters and operations can be chained together to build complex queries. Example:\npython Copy code queryset = Model.objects.filter(field1=value1).exclude(field2=value2).order_by(\u0026rsquo;-date_created\u0026rsquo;) Slicing:\nQuerysets can be sliced to retrieve a specific range of objects. Example:\npython Copy code queryset = Model.objects.all() result_slice = queryset[5:10] # Retrieve objects 5 through 9 Count:\nThe count method returns the number of objects in the queryset without fetching the actual objects. Example:\npython Copy code count = queryset.count() Distinct:\nThe distinct method eliminates duplicate rows from the queryset. Example:\npython Copy code distinct_values = Model.objects.values(\u0026lsquo;field\u0026rsquo;).distinct() Aggregate:\nThe aggregate method allows for the calculation of aggregate values (e.g., sum, average) on the queryset. Example:\npython Copy code from django.db.models import Avg average_value = Model.objects.aggregate(avg_value=Avg(\u0026rsquo;numeric_field\u0026rsquo;)) Values and ValuesList:\nThe values method returns a queryset of dictionaries representing the values of specific fields. The values_list method returns a queryset of tuples representing the values of specific fields. Example:\npython Copy code values_queryset = Model.objects.values(\u0026lsquo;field1\u0026rsquo;, \u0026lsquo;field2\u0026rsquo;) values_list_queryset = Model.objects.values_list(\u0026lsquo;field1\u0026rsquo;, \u0026lsquo;field2\u0026rsquo;) Exists:\nThe exists method checks if there are any records in the queryset. Example:\nqueryset_exists = Model.objects.filter(field=value).exists() Update and Delete:\nThe update method modifies multiple records in the database without fetching them. The delete method deletes records from the database without fetching them. Example:\npython Copy code Model.objects.filter(field=value).update(status=\u0026lsquo;new_status\u0026rsquo;) Model.objects.filter(field=value).delete() These are just a few of the many properties and methods provided by Django querysets. They offer a powerful and expressive way to interact with the database.\nEsempio in wagtail from datetime import datetime, timedelta, timezone from django.shortcuts import render from wagtail.core.models import Page from your_app.models import RoundPage # Replace \u0026lsquo;your_app\u0026rsquo; with the actual name of your app from path.to.get_deadline_date_for import get_deadline_date_for # Replace \u0026lsquo;path.to\u0026rsquo; with the actual path\ndef docs_internship(request): now = datetime.now(timezone.utc) today = get_deadline_date_for(now) five_weeks_ago = today - timedelta(days=7 * 5)\napplicant_round = RoundPage.objects.filter( pingnew__lte=today, internannounce__gt=today, ).first() intern_round = RoundPage.objects.filter( internannounce__lte=today, internends__gt=five_weeks_ago, ).first() return render(request, 'home/docs/internship_guide.html', { 'applicant_round': applicant_round, 'intern_round': intern_round, }) # Strumenti avanzati: Creare una pagina wagtail all\u0026rsquo;interno di un sito Django (link)[https://docs.wagtail.org/en/latest/advanced_topics/add_to_django_project.html]\nInstallazione in Django al pari livello di manage.py: python3 manage.py startapp blog_wiki_wag\nVerifica in Wagtail di requirements.txt della compatibilità delle versioni tra Django e Wagtail. Nel caso specifico Django\u0026gt;=4.2,\u0026lt;4.3 - wagtail\u0026gt;=5.1,\u0026lt;5.2\nVerifica in Django di requirements.txt: Django==4.2.2\nSe vi è compatibilità in Wagtal: pip3 freeze requriments.txt\n*** Verifica del motore Database in Wagtail in base.py: ***\nDATABASES = { \u0026quot;default\u0026quot;: { \u0026quot;ENGINE\u0026quot;: \u0026quot;django.db.backends.sqlite3\u0026quot;, \u0026quot;NAME\u0026quot;: os.path.join(BASE_DIR, \u0026quot;db.sqlite3\u0026quot;), } }\n*** Verifica del motore database in Django in settings.py: ***\nDATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': BASE_DIR / 'db.sqlite3', } }\nCome si può vedere sopra i due motori DB sono identici\nOra creare la subdirectory di progetto wagtail che conterrà tutti i file dell\u0026rsquo;app wagtail (quella con il quale si effettuato il requirements.txt)\neffettuare il clone del branch da GB del progetto wagtail (vedere git e github per i dettagli)\na questo punto lanciare il comando Install the Project:\nNavigate to the wagtail-wag directory in your terminal: pip install -r requirements.txt\nAdd Wagtail URLs to Django URLs: path('wagtail/', include('wiki-wag.wagtail_urls')), # nuovo inserimento\nAdd the required wagtail modules in setting.py: `INSTALLED_APPS = [\n\u0026lsquo;wagtail.contrib.forms\u0026rsquo;, \u0026lsquo;wagtail.contrib.redirects\u0026rsquo;, \u0026lsquo;wagtail.embeds\u0026rsquo;, \u0026lsquo;wagtail.sites\u0026rsquo;, \u0026lsquo;wagtail.users\u0026rsquo;, \u0026lsquo;wagtail.snippets\u0026rsquo;, \u0026lsquo;wagtail.documents\u0026rsquo;, \u0026lsquo;wagtail.images\u0026rsquo;, \u0026lsquo;wagtail.search\u0026rsquo;, \u0026lsquo;wagtail.admin\u0026rsquo;,\n\u0026rsquo;taggit\u0026rsquo;, \u0026lsquo;modelcluster\u0026rsquo;,\n\u0026lsquo;django.contrib.admin\u0026rsquo;, \u0026lsquo;django.contrib.auth\u0026rsquo;, \u0026lsquo;django.contrib.contenttypes\u0026rsquo;, \u0026lsquo;django.contrib.sessions\u0026rsquo;, \u0026lsquo;django.contrib.messages\u0026rsquo;, \u0026lsquo;django.contrib.staticfiles\u0026rsquo;, \u0026lsquo;sgq\u0026rsquo;, \u0026lsquo;wagtail\u0026rsquo;, ]`\nAdd\u0026rsquo;wiki-wag\u0026rsquo; app in your Django INSTALLED_APPS as well. Add it if it\u0026rsquo;s not present.\nINSTALLED_APPS = [ # \u0026hellip; \u0026lsquo;wiki-wag\u0026rsquo;, # \u0026hellip; ]\nadd in Django settings this: ` MIDDLEWARE = [ \u0026lsquo;django.contrib.sessions.middleware.SessionMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.common.CommonMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.csrf.CsrfViewMiddleware\u0026rsquo;, \u0026lsquo;django.contrib.auth.middleware.AuthenticationMiddleware\u0026rsquo;, \u0026lsquo;django.contrib.messages.middleware.MessageMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.security.SecurityMiddleware\u0026rsquo;,\n\u0026lsquo;wagtail.contrib.redirects.middleware.RedirectMiddleware\u0026rsquo;, ] `\nA questo punto dvrebbe apparire un Warning che indica qualcosa di questo genere :::caution WARNINGS: ?: (wagtailadmin.W003) The WAGTAILADMIN_BASE_URL setting is not defined HINT: This should be the base URL used to access the Wagtail admin site. Without this, URLs in notification emails will not display correctly :::\nProseguire e verificare se in admin panel appaiono gli elementi di inpunt in Admin Panel\nSo now update the urls and run makemirgations and migrate from django.contrib import admin from django.urls import path, include from wagtail import urls as wagtail_urls\nurlpatterns = [ path(\u0026rsquo;\u0026rsquo;, include(\u0026lsquo;sgq.urls\u0026rsquo;)), # Include the app-level URLs path(\u0026lsquo;admin/\u0026rsquo;, admin.site.urls), # path(\u0026lsquo;wagtail/\u0026rsquo;, include(\u0026lsquo;wagtail.core.urls\u0026rsquo;)), # nuovo inserimento path(\u0026lsquo;wagtail/\u0026rsquo;, include(wagtail_urls)), # nuovo inserimento\n]\nDJANGO Create a Django App from 0 (from Create Django API App ) Step 1: Create a Virtual Environment (Optional but recommended) Open your terminal and navigate to the directory where you want to create your Django project. Run the following commands:\npython3 -m venv venv source venv/bin/activate Step 2: Install Django While in the activated virtual environment, install Django using the following command:\npip3 install django Step 3: Create a Django Project\nRun the following command to create a new Django project:\ndjango-admin startproject progetto_api Replace myproject with the desired name for your project.\nStep 4: Navigate to the Project Directory Change into the project directory:\ncd progetto_api Step 5: Create a Django App Run the following command to create a new Django app:\npython3 manage.py startapp django_api_for_wagtail Step 6: Configure Database Open the myproject/settings.py file and configure the app and the database settings. By default, Django uses SQLite for development (if not already configured):\n# myproject/settings.py INSTALLED_APPS = [ # ... \u0026#39;django_api_for_wagtail\u0026#39;, # ... ] # .... # DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#34;db.sqlite3\u0026#34;, } } Step 7: Apply Migrations Run the following commands to apply initial migrations:\npython3 manage.py makemigrations python3 manage.py migrate Step 8: Create a Superuser (Optional but recommended) Run the following command to create a superuser account for the Django admin:\nbashCopy code python manage.py createsuperuser Follow the prompts to set a username, email, and password.\nStep 9: Run the Development Server Start the Django development server:\npython3 manage.py runserver Visit http://127.0.0.1:8000/ in your web browser to see the Django welcome page.\nStep 10: Create a Superuser After running the development server return e to your project directory (at manage.py level).\nRun the following command to create a superuser account:\npython3 manage.py createsuperuser Follow the prompts to set a username, email, and password for the superuser account.\nStep 11: Run the Development Server Ensure that the development server is still running:\npython3 manage.py runserver Step 12: Open the Admin Interface Visit http://127.0.0.1:8000/admin/ in your web browser. Log in with the superuser credentials you just created.\nStep 13: Verify Admin Interface Verify that the Django admin interface is working correctly\nStep 14: Initialize a Git Repository Open a new terminal window in your project directory\nThe Git commands to initialize a repository, add files, and make an initial commit should be executed at the root level of your project, where your manage.py file is located. The manage.py file is typically located at the top level of your Django project, not within the virtual environment (venv).\nRun the following commands to initialize a Git repository, add all files, and make an initial commit:\ngit init git add . git commit -m \u0026#34;Initial commit\u0026#34; Step 15: Create a GitHub Repository Go to the GitHub website and log in or create a new account. Click on the \u0026ldquo;+\u0026rdquo; icon in the top right corner and select \u0026ldquo;New repository.\u0026rdquo; Follow the instructions to create a new repository on GitHub. git repo name https://github.com/progettazionemauro/django-api Step 16: Connect Local Repository to GitHub After creating the GitHub repository follow those instructions.\ngit remote add origin https://github.com/progettazionemauro/django-api\ngit branch -M main\nnote: The git branch -M main command is used to rename the current branch. In Git, it\u0026rsquo;s a way to both rename the current branch and force-update the tracking branches.\nHere\u0026rsquo;s what the command does:\ngit branch: This command is used for creating, listing, renaming, and deleting branches in Git. When used without additional options, it lists all the local branches. -M main: This option is used to rename the current branch to \u0026ldquo;main\u0026rdquo;. The -M flag is a shortcut for --move, which is used for renaming branches. When you create a new Git repository or clone an existing one, the default branch is usually named \u0026ldquo;master.\u0026rdquo; However, in recent years, there has been a movement in the Git community to use more inclusive and neutral terminology. As a result, many projects are now using \u0026ldquo;main\u0026rdquo; instead of \u0026ldquo;master\u0026rdquo; as the default branch name.\nThe git branch -M main command is often used after creating a new repository or when transitioning from \u0026ldquo;master\u0026rdquo; to \u0026ldquo;main\u0026rdquo; to update the branch name.\nIt\u0026rsquo;s important to note that if you\u0026rsquo;re renaming the branch you are currently on, you might need to update the remote repository to reflect the new branch name.\ngit remote add origin https://github.com/progettazionemauro/django-api git branch -M main git push -u origin main Make sure to replace \u0026ldquo;your-username\u0026rdquo; and \u0026ldquo;your-repo\u0026rdquo; with your GitHub username and repository name.\nStep 16 bis: problems with git push In doing push it can happen to find issues related to pushing for the first time into Github. For example when you created the repo and added readme.md and it is not present into local repo this can generate a misealignment that che lead to generate an error likse that:\ngit push origin main `To https://github.com/progettazionemauro/django-api` `! [rejected] main -\u0026gt; main (non-fast-forward)` `error: push di alcuni riferimenti su \u0026#39;https://github.com/progettazionemauro/django-api\u0026#39; non riuscito` `suggerimento: Gli aggiornamenti sono stati rifiutati perché l\u0026#39;ultimo commit del branch` `suggerimento: attuale è rimasto indietro rispetto alla sua controparte remota.` `suggerimento: Integra le modifiche remote (ad es. con \u0026#39;git pull ...\u0026#39;) prima di` `suggerimento: eseguire nuovamente il push.` `suggerimento: Vedi la \u0026#39;Nota sui fast forward\u0026#39; in \u0026#39;git push --help\u0026#39; per ulteriori` `suggerimento: dettagli.` So it this is the case the best option if to do this:\nIn alternativa, puoi anche eseguire il comando:git push --force per forzare il push delle tue modifiche, anche se non sono un fast forward. Tuttavia, questa è una soluzione rischiosa perché potrebbe sovrascrivere le modifiche remote che non hai ancora integrato nel tuo branch locale.\nPer capire meglio cosa significa \u0026ldquo;non-fast-forward\u0026rdquo;, è necessario comprendere il concetto di fast forward. Un fast forward è un tipo di push che aggiorna un branch locale con le ultime modifiche apportate a un branch remoto. Il fast forward è possibile solo se le modifiche apportate ai due branch sono consecutive.\nStep 16: Verify GitHub Repository Go to your GitHub repository in the web browser and verify that your code has been pushed successfully.\nThat\u0026rsquo;s it! Now you have a Django project with a superuser account, and your code is version-controlled using Git and hosted on GitHub.\nStep 10: Create Models, Views, and Templates (Optional) You can now start building your Django app by creating models, views, and templates. Define your models in the models.py file, create views in the views.py file, and add templates in the templates directory.\nStep 11: Create API App (Optional) If you want to create a separate app for your API, follow the instructions provided in the previous response to create an api app and set up serializers, views, and URLs.\nThat\u0026rsquo;s it! You now have a basic Django project and app set up. Customize it based on your specific requirements and integrate it with your Wagtail project as needed.\n","permalink":"http://localhost:1313/posts/il_mio_secondo_post/","summary":"[toc]\nMARKUP HINTS By Mauro alle h.13:16 I have my README.md inside my project. Here are a method to work with your README.md separately while working on your vsc local project: Use an external Markdown editor like\n** (a minimal markdown editor and reader) **. These editors provide a live preview feature by default.\nBASH trovare la oporta occupata:\nlsof -i :8000 chiudere la porta occupata forzatamente:\nkill -9 32394(esempio) vedere i comandi che iniziano per una determinata strina effettuati in precedenza:","title":"Installazione del Tema in Hugo"},{"content":"[toc]\nMARKUP HINTS I have my README.md inside my project. Here are a method to work with your README.md separately while working on your vsc local project: Use an external Markdown editor like\n** (a minimal markdown editor and reader) **. These editors provide a live preview feature by default.\nBASH trovare la oporta occupata:\nlsof -i :8000 chiudere la porta occupata forzatamente:\nkill -9 32394(esempio) vedere i comandi che iniziano per una determinata strina effettuati in precedenza:\nhistory | grep \u0026quot;kill (esempio)\u0026quot; trovare la porta occupata:\nlsof -i :8000 chiudere la porta occupata forzatamente:\nkill -9 32394(esempio) vedere i comandi che iniziano per una determinata strina effettuati in precedenza:\nhistory | grep \u0026quot;kill (esempio)\u0026quot; Azione Bash - Quello che segue è uno script molto importante che permette nell\u0026rsquo;ordine di 1) verificare se la porta 8000 (che viene utilizzata normalmente in fase di sviluppo) è occupata ed eventualmente chiuderla; 2) aprire Django 3) aprire hugo. Al momento sono presenti due file separati per una migliore comprensione:\n- check_ports.sh \\#!/bin/bash \\# Check if any process is listening on port 8000 if lsof -i :8000 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then ​ echo \u0026#34;Port 8000 is in use.\u0026#34; ​ \\# Get the PID of the process using port 8000 ​ pid=$(lsof -ti :8000) ​ \\# Kill the process ​ echo \u0026#34;Killing process with PID $pid\u0026#34; ​ kill -9 \u0026#34;$pid\u0026#34; ​ echo \u0026#34;Process killed.\u0026#34; else ​ echo \u0026#34;Port 8000 is not in use.\u0026#34; fi run_project.sh #!/bin/bash # Navigate to the Django project directory and run the server # cd /progetto_api python3 manage.py runserver \u0026amp; # Navigate to the Hugo project directory and run the server cd ./sgb_start/ hugo server -D Per cui lo script generare APRIRE I DUE PROGRAMMI DJANGO E HUGO è il seguente (ADA PERFEZIONARE!!):\n#!/bin/bash # Check if any process is listening on port 8000 if lsof -i :8000 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;Port 8000 is in use.\u0026#34; # Get the PID of the process using port 8000 pid=$(lsof -ti :8000) # Kill the process echo \u0026#34;Killing process with PID $pid\u0026#34; kill -9 \u0026#34;$pid\u0026#34; echo \u0026#34;Process killed.\u0026#34; else echo \u0026#34;Port 8000 is not in use.\u0026#34; fi # Navigate to the Django project directory and run the server # cd /progetto_api python3 manage.py runserver \u0026amp; # Navigate to the Hugo project directory and run the server cd ./sgb_start/ hugo server -D Mentre il codice per chiudere i due programmi DJANGO e HUGO è il seguente (da perfezionare)!!!:\n# Find Django PID and send SIGTERM signal django_pid=$(pidof python) \u0026amp;\u0026amp; kill \u0026#34;$django_pid\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Django process terminated\u0026#34; # Find Hugo PID and send SIGTERM signal hugo_pid=$(pidof hugo) \u0026amp;\u0026amp; kill \u0026#34;$hugo_pid\u0026#34; \u0026amp;\u0026amp; echo \u0026#34;Hugo process terminated\u0026#34; ps aux | grep \u0026#34;python manage.py runserver\u0026#34;; reset GIT \u0026amp; GITHUB Riferimenti Mastering MarkDown\nRicordarsi di aggiungere .gitgnore - git add .gitignore - git commit -m \u0026ldquo;Add .gitignore to exclude compiled Python files\u0026rdquo;\nPer effettuare il push da origine a remoto - git push origin implementazione-pagina\nSwitch to the New Branch: - git checkout new-branch-name\nCreare una nuova branch e posizionarsi sulla stessa git checkout -b new-branch-name (Il comando può essere visto come la sintesi dei due seguenti comandi:) - git branch new-branch-name # Create a new branch - git checkout new-branch-name # Switch to the new branch\nYou\u0026rsquo;ve created a new branch (template-tutorial) without committing changes on your existing branch (implementazione-pagina) To address this, you\u0026rsquo;ll need to follow these steps to commit your changes on the implementazione-pagina branch and then switch back to the template-tutorial branch. Here\u0026rsquo;s a step-by-step guide:\nCommit Changes on implementazione-pagina: Assuming you are currently on the template-tutorial branch, ** switch back to the implementazione-pagina branch:** git checkout implementazione-pagina\nNow, add and commit your changes:\ngit add . git commit -m \u0026quot;Your commit message here\u0026quot;\nPush Changes to Remote (implementazione-pagina): Assuming the remote branch is named implementazione-pagina: git push origin implementazione-pagina\n** Switch Back to template-tutorial:** Now, switch back to the template-tutorial branch: git checkout template-tutorial\nIf you haven\u0026rsquo;t pushed the template-tutorial branch yet, you can push it to the remote repository when you\u0026rsquo;re ready:\ngit push origin template-tutorial\nHow can see from my vsc local if a git branch is present also in the remote github?\ngit fetch --all git branch -a This fetches all branches from the remote repository and lists both local and remote branches. Remote branches are prefixed with \u0026ldquo;remotes/origin/\u0026rdquo;. Check if your branch is listed among the remotes.\nCome posso creare una nuova branch in local, e poi crearla anche in Github, poi effettuare il push e rendere questa branch principale?\nCreate a new branch locally and switch to it (chimiamo la nuova branch template-tutorial): git checkout -b template-tutorial\nPush the new branch to GitHub:\ngit push origin template-tutorial\nSet the upstream for the new branch:\ngit branch --set-upstream-to=origin/template-tutorial template-tutorial![alt]( \u0026lsquo;{\u0026ldquo;class\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;title\u0026rdquo;: \u0026ldquo;\u0026rdquo;}\u0026rsquo;)\nNow, further pushes can be simplified to:\ngit push\nTo revert the changes and go back to the original commit before the changes, you can use the following commands: git reset --hard HEAD git clean -fd\nThe first command (git reset \u0026ndash;hard HEAD) resets your branch to the latest commit, discarding changes. The second command (git clean -fd) removes untracked files and directories. Use them with caution, as they are not reversible.\n-fd stands for what? In the context of the git clean command:\n-f stands for force. -d stands for directory. Together, -fd means force removal of untracked directories. This option is used to remove untracked files and directories forcefully.\ndelete a local branch and also delete it on the remote repository on GitHub Delete the local branch:\ngit branch -d branch_name![alt]( \u0026lsquo;{\u0026ldquo;class\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;title\u0026rdquo;: \u0026ldquo;\u0026rdquo;}\u0026rsquo;)\nReplace branch_name with the name of the branch you want to delete.\nIf the branch contains unmerged changes, you might need to force delete it:\ngit branch -D branch_name\nDelete the remote branch:\ngit push origin --delete branch_name\nThis will delete the branch on the remote repository (GitHub).\nUpdate your local repository to reflect the changes on the remote:\ngit fetch --prune\nThe \u0026ndash;prune flag removes any remote tracking branches that no longer exist on the remote.\nI want to synch another an oldest branch named \u0026ldquo;template-tutorial\u0026rdquo; with a newest branch named template-sheetlike and after delete this last one (template-sheetlike) Switch to the template-tutorial branch: git switch template-tutorial\nRebase template-sheetlike onto template-tutorial: git rebase template-sheetlike\nPush the changes to the remote repository: git push origin template-tutorial --force Note: Force-pushing after a rebase rewrites the commit history. Use it with caution, especially if the branch has already been shared with others\nDelete the template-sheetlike branch: git branch -d template-sheetlike git push origin --delete template-sheetlike\nAutomate the copy of a file from a repo to another when pushing the commit So let\u0026rsquo;s say that i have cheatsheet.md that i update regularly as it would be a wiki page. This file with the same name is present on different local repo. Let\u0026rsquo;s say that i am working into my local repo named /home/mauro/Scrivania/dJANGO_apI/progetto_api/cheatsheet.md.md. When I do a commit adn after a push into github repo https://github.com/progettazionemauro/django-api I want automatically copy this file and update the commit also into my https://github.com/progettazionemauro/wiki-wag How can do that automatically?\nTo automatically copy and update the cheatsheet.md file in another GitHub repository whenever you push changes to the first repository, you can use GitHub Actions. GitHub Actions allows you to define workflows that run in response to various events, such as pushing to a repository. Here\u0026rsquo;s a simple example:\nTheory Create a GitHub Actions Workflow: In your Django API repository (https://github.com/progettazionemauro/django-api), create a directory named .github/workflows if it doesn\u0026rsquo;t already exist.\nInside this directory, create a file named, for example, sync_cheatsheet.yml with the following content:\nname: Sync Cheatsheet on: push: branches: - main jobs: sync: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Copy cheatsheet to other repository run: | cp cheatsheet.md /path/to/wiki-wag-repo cd /path/to/wiki-wag-repo git config user.email \u0026#34;your-email@example.com\u0026#34; git config user.name \u0026#34;Your Name\u0026#34; git add cheatsheet.md git commit -m \u0026#34;Sync cheatsheet from django-api repository\u0026#34; git push origin main Replace /path/to/wiki-wag-repo with the actual path to your local wiki-wag repository.\nCommit and Push Workflow:\nCommit the changes and push them to your Django API repository:\ngit add .github/workflows/sync_cheatsheet.yml git commit -m \u0026#34;Add sync cheatsheet workflow\u0026#34; git push origin main Run the Workflow:\nThe workflow will run automatically when you push changes to the main branch. It will copy the cheatsheet.md file to the specified path in the wiki-wag repository and commit the changes there.\nMake sure to replace the placeholder values in the workflow file (your-email@example.com, Your Name, and /path/to/wiki-wag-repo) with your actual email, name, and the path to the wiki-wag repository.\nHere are step-by-step instructions to set up the GitHub Actions workflow for syncing the cheatsheet.md file from the Django API repository to the wiki-wag repository:\nStep 1: Create the Workflow File Open your Django API repository in your code editor or on GitHub.\nInside the .github/workflows directory (create it if it doesn\u0026rsquo;t exist), create a new file named, for example, sync_cheatsheet.yml.\nCopy and paste the following content into sync_cheatsheet.yml:\nyamlCopy codename: Sync Cheatsheet on: push: branches: - main jobs: sync: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Copy cheatsheet to other repository run: | cp cheatsheet.md /path/to/wiki-wag-repo cd /path/to/wiki-wag-repo git config user.email \u0026#34;your-email@example.com\u0026#34; git config user.name \u0026#34;Your Name\u0026#34; git add cheatsheet.md git commit -m \u0026#34;Sync cheatsheet from django-api repository\u0026#34; git push origin main Replace /path/to/wiki-wag-repo, \u0026quot;your-email@example.com\u0026quot;, and \u0026quot;Your Name\u0026quot; with the actual path to your local wiki-wag repository, your email, and your GitHub username.\nStep 2: Commit and Push Workflow File In your terminal, navigate to the Django API repository.\nRun the following commands to stage, commit, and push the workflow file:\nbashCopy codegit add .github/workflows/sync_cheatsheet.yml git commit -m \u0026#34;Add sync cheatsheet workflow\u0026#34; git push origin main Step 3: Run the Workflow Visit the Actions tab on your GitHub repository to see the status of your workflow. You should see the \u0026ldquo;Sync Cheatsheet\u0026rdquo; workflow running or completed. Step 4: Verify Changes in the wiki-wag Repository After the workflow completes, check your wiki-wag repository for the synced changes to the cheatsheet.md file.\nIf there are any issues or changes are not reflected as expected, review the GitHub Actions logs for the workflow to identify potential errors.\nThat\u0026rsquo;s it! You\u0026rsquo;ve set up a GitHub Actions workflow to automatically sync the cheatsheet.md file from the Django API repository to the wiki-wag repository on each push to the main branch.\nBreak down the content of the GitHub Actions workflow file step by step: name: Sync Cheatsheet This line sets the name of the GitHub Actions workflow to \u0026ldquo;Sync Cheatsheet.\u0026rdquo; push: branches: - main This section specifies the trigger for the workflow. The workflow will be triggered on each push to the main branch. sync: runs-on: ubuntu-latest Here, we define a job named \u0026ldquo;sync\u0026rdquo; that will run on the latest version of the Ubuntu operating system. steps: - name: Checkout repository uses: actions/checkout@v2 This step checks out the code from the repository, allowing subsequent steps to operate on the repository\u0026rsquo;s contents. uses: actions/checkout@v2: This part specifies the action that will be used for this step. In GitHub Actions, an action is a reusable unit of code. The actions/checkout action is provided by GitHub and is commonly used to check out the source code of the repository. @v2: This refers to the version of the actions/checkout action to use. In this case, it\u0026rsquo;s version 2 of the action. The @v2 is a version tag that indicates a specific release or version of the action. Using a version tag ensures that the workflow is using a stable and known version of the action, making it less prone to unexpected changes. - name: Copy cheatsheet to other repository run: | cp cheatsheet.md /path/to/wiki-wag-repo cd /path/to/wiki-wag-repo In this step, the cheatsheet.md file is copied from the current repository to the specified path (/path/to/wiki-wag-repo). The subsequent commands are executed within the wiki-wag repository. git config user.email \u0026#34;your-email@example.com\u0026#34; git config user.name \u0026#34;Your Name\u0026#34; These commands set the global Git configuration for the user\u0026rsquo;s email and name in the wiki-wag repository. git add cheatsheet.md This command stages the changes to the cheatsheet.md file for the next commit. git commit -m \u0026#34;Sync cheatsheet from django-api repository\u0026#34; This command creates a new commit with a commit message indicating that the cheatsheet.md file is being synced from the django-api repository. git push origin main Finally, this command pushes the changes to the remote repository (origin) on the main branch.\nReal Case: If I have another branch othe then main in repo2 I can do it: name: Sync Cheatsheet on: push: branches: - main jobs: sync: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 with: ref: opzione-pagina # Specify the branch you want to sync Summary The GitHub Actions workflow automates the process of syncing the cheatsheet.md file from the django-api repository to the wiki-wag repository. It does so by copying the file, committing the changes, and pushing the commit to the main branch of the wiki-wag repository whenever changes are pushed to the main branch of the django-api repository.\nSome useful notes Merge: Creates Merge Commits: When you merge one branch into another, Git creates a new merge commit that has two parent commits: one from the branch you\u0026rsquo;re merging and another from the branch you\u0026rsquo;re merging into. This results in a non-linear history with multiple branches merging into each other Preserves Original History:\nThe original commits from both branches remain unchanged. This approach keeps a clear record of when changes were made on each branch.\nRebase: Linearizes History:\nRebase is used to linearize the commit history. It moves or combines a sequence of commits to a new base commit. When you rebase one branch onto another, it effectively transplants the entire branch onto the tip of the other branch, creating a linear history. No Merge Commits:\nUnlike merge, rebase doesn\u0026rsquo;t create additional merge commits. It can result in a cleaner, more linear history. When to Choose Each Approach: Merge:\nUse merge when you want to preserve the original commit history, especially when collaborating with others. Good for feature branches and when you want to maintain a clear record of branch integration points. Rebase:\nUse rebase when you want a clean, linear history and don\u0026rsquo;t mind rewriting commits. Useful for feature branches before merging into a shared branch to avoid unnecessary merge commits. Switch vs. Checkout: git switch is a more modern and user-friendly command introduced in recent versions of Git. It is designed specifically for branch switching. If you\u0026rsquo;re using a version of Git that supports git switch, you can replace git checkout with git switch:\nSwitching Branch: git switch template-tutorial Both commands essentially do the same thing in this context, but git switch provides a clearer and more explicit syntax for branch-related operations. If your Git version supports it, feel free to use git switch instead of git checkout.\nGIT CHEATSHEET git command to see the last 3 commit with oneline :\ngit log --oneline -n 3 WAGTAIL How to use StreamField for mixed content StreamField block reference Templating - Jinja Wrinting Templates La regola da seguire è questa:\ncode: class wagtail.fields.StreamField(blocks, use_json_field=None, blank=False, min_num=None, max_num=None, block_counts=None, collapsed=False)\nE questa la spiegazione:\nclass wagtail.fields.StreamField: This line defines a class named StreamField in the wagtail.fields module.\n(blocks, use_json_field=None, blank=False, min_num=None, max_num=None, block_counts=None, collapsed=False): These are the parameters that the StreamField class constructor (init method) accepts. Let\u0026rsquo;s go through each one:\nblocks: This is a required parameter. It represents the blocks that can be used in the stream. It seems like it should be provided when creating an instance of StreamField.\nuse_json_field=None: This is an optional parameter with a default value of None. It allows you to specify whether to use a JSON field for storage. If not provided, it defaults to None.\nblank=False: This is an optional parameter with a default value of False. It indicates whether the field is allowed to be blank when used in a form. If not provided, it defaults to False.\nmin_num=None: This is an optional parameter with a default value of None. It specifies the minimum number of blocks required. If not provided, it defaults to None.\nmax_num=None: This is an optional parameter with a default value of None. It specifies the maximum number of blocks allowed. If not provided, it defaults to None.\nblock_counts=None: This is an optional parameter with a default value of None. It seems related to counting blocks. If not provided, it defaults to None.\ncollapsed=False: This is an optional parameter with a default value of False. It indicates whether the blocks should be collapsed in the Wagtail admin interface. If not provided, it defaults to False\nCosì ad esempio per questo codice. Possiamo effettuare il breakdown di questo codice in base alla regola definita:\n`class BlogPage(Page): author = models.CharField(max_length=255, default=\u0026lsquo;Default Author\u0026rsquo;) date = models.DateField(\u0026ldquo;Post date\u0026rdquo;)\nbody = StreamField( [ ('heading', blocks.CharBlock(form_classname=\u0026quot;title\u0026quot;)), ('paragraph', blocks.RichTextBlock()), ('image', ImageChooserBlock()), ('code', CodeBlock()), ('raw_html', RawHTMLBlock()), ], use_json_field=True ) content_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('body'), ] `\nauthor = models.CharField(max_length=255, default=\u0026lsquo;Default Author\u0026rsquo;): This line defines a character field named author in the BlogPage class. It has a maximum length of 255 characters and a default value of \u0026lsquo;Default Author\u0026rsquo;.\ndate = models.DateField(\u0026ldquo;Post date\u0026rdquo;): This line defines a date field named date in the BlogPage class with a human-readable name \u0026ldquo;Post date\u0026rdquo;.\nbody = StreamField([\u0026hellip;], use_json_field=True): This line defines a stream field named body in the BlogPage class. It allows the inclusion of different block types, such as CharBlock, RichTextBlock, ImageChooserBlock, CodeBlock, and RawHTMLBlock. The use_json_field parameter is set to True, indicating that a JSON field will be used for storage.\ncontent_panels = Page.content_panels + [\u0026hellip;]: This line defines the content panels for the Wagtail admin interface. It includes panels for \u0026lsquo;author\u0026rsquo;, \u0026lsquo;date\u0026rsquo;, and \u0026lsquo;body\u0026rsquo;.\nPoi in particolare:\ncontent_panels definition in the BlogPage class: content_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('body'), ]\nPage.content_panels: This part includes the content panels defined in the parent Page class. It allows the inclusion of standard page fields, such as title, slug, publish date, etc.\nFieldPanel(\u0026lsquo;author\u0026rsquo;): This adds a panel for the author field to the content panels. It\u0026rsquo;s likely a simple text input for the author\u0026rsquo;s name.\nFieldPanel(\u0026lsquo;date\u0026rsquo;): This adds a panel for the date field, probably a date picker for selecting the post date.\nFieldPanel(\u0026lsquo;body\u0026rsquo;): This adds a panel for the body field. Since it\u0026rsquo;s a StreamField, it might include a dynamic set of blocks like headings, paragraphs, images, code blocks, and raw HTML.\nUso dello StructBox in Wagtail Example Model with StructBlock Consider a simple model for a page with a StreamField containing a StructBlock named \u0026lsquo;person\u0026rsquo;:\n` # models.py from django.db import models from wagtail.core.fields import StreamField from wagtail.core import blocks from wagtail.images.blocks import ImageChooserBlock from wagtail.core.models import Page from wagtail.admin.edit_handlers import FieldPanel, StreamFieldPanel\nclass BlogPage(Page): body = StreamField([ (\u0026lsquo;person\u0026rsquo;, blocks.StructBlock([ (\u0026lsquo;first_name\u0026rsquo;, blocks.CharBlock()), (\u0026lsquo;surname\u0026rsquo;, blocks.CharBlock()), (\u0026lsquo;photo\u0026rsquo;, ImageChooserBlock(required=False)), (\u0026lsquo;biography\u0026rsquo;, blocks.RichTextBlock()), ])), (\u0026lsquo;heading\u0026rsquo;, blocks.CharBlock(form_classname=\u0026ldquo;title\u0026rdquo;)), (\u0026lsquo;paragraph\u0026rsquo;, blocks.RichTextBlock()), (\u0026lsquo;image\u0026rsquo;, ImageChooserBlock()), ], use_json_field=True)\ncontent_panels = Page.content_panels + [ StreamFieldPanel('body'), ] `\u0026lt;/span\u0026gt; Diagram Explanation Blog Page with StreamField and StructBlock:\nA BlogPage contains a StreamField named \u0026lsquo;body\u0026rsquo;. \u0026lsquo;body\u0026rsquo; includes various block types, one of which is a StructBlock named \u0026lsquo;person\u0026rsquo;. Person StructBlock:\nThe \u0026lsquo;person\u0026rsquo; block is a StructBlock containing fields like \u0026lsquo;first_name\u0026rsquo;, \u0026lsquo;surname\u0026rsquo;, \u0026lsquo;photo\u0026rsquo;, and \u0026lsquo;biography\u0026rsquo;. Block Instances:\nWhen editing a BlogPage, you can add multiple instances of different block types, including \u0026lsquo;person\u0026rsquo;. Each \u0026lsquo;person\u0026rsquo; block instance can have its own \u0026lsquo;first_name\u0026rsquo;, \u0026lsquo;surname\u0026rsquo;, \u0026lsquo;photo\u0026rsquo;, and \u0026lsquo;biography\u0026rsquo;\nTemplate Implementation\nTo render this in a template, you can use the following:\n`\u0026lt;!-- templates/blog_page.html --\u0026gt; {% extends \u0026#34;base.html\u0026#34; %} {% block content %} \u0026lt;article\u0026gt; {% for block in page.body %} {% if block.block_type == \u0026#39;person\u0026#39; %} \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; {% if block.value.photo %} {% image block.value.photo width-400 %} {% endif %} \u0026lt;h2\u0026gt;{{ block.value.first_name }} {{ block.value.surname }}\u0026lt;/h2\u0026gt; {{ block.value.biography }} \u0026lt;/div\u0026gt; {% else %} {# Rendering for other block types #} \u0026lt;section class=\u0026#34;{{ block.block_type }}\u0026#34;\u0026gt; {% include_block block %} \u0026lt;/section\u0026gt; {% endif %} {% endfor %} \u0026lt;/article\u0026gt; {% endblock %} Database Initialization\nWhen you run makemigrations and migrate after adding the StructBlock to your model, the necessary database tables and fields are created. The use_json_field=True parameter in the StreamField indicates that the data for the StreamField will be stored as JSON in the database.\nHere\u0026rsquo;s how you perform the migration:\nbash Copy code python manage.py makemigrations python manage.py migrate After migration, you can create or edit a BlogPage instance through the Wagtail admin interface. The StructBlock fields will be part of the form for each \u0026lsquo;person\u0026rsquo; block within the \u0026lsquo;body\u0026rsquo; StreamField.\nRiferimenti Rapidi Wagtail Caso Studio web page How to use Streamfield for mixed content StreamFieldBlock Reference Caratteristiche avanzate di Diango - Wagtail Uno dei porblemi che si incontrano effettuando delle tabelle all\u0026rsquo;interno di wagtail ma in generale anche in Django è il caso pratico della renderizzazione degli headers di una tabella se si vogliono recuperare ad esempio i dati all\u0026rsquo;interno delle celle della tabella.\nQuesto codice di esempio effettua il debug su ciò che è successo:\n` {% for column in block.value.columns %} {{ column.header|default:\u0026ldquo;Column Header\u0026rdquo; }}\n\u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: {{ block.value.rows|list }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: {{ block.value.rows|list.1|default:\u0026quot;\u0026quot; }}\u0026lt;/p\u0026gt; {% with block.value.rows|list.1|default:\u0026quot;\u0026quot; as row_values %} {{ row_values.0|default:\u0026quot;\u0026quot; }} {% endwith %} \u0026lt;/th\u0026gt; {% endfor %} \u0026lt;/tr\u0026gt; \u0026lt;th\u0026gt; Column Header \u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: \u0026amp;lt;generator object TypedTable.rows at 0x7f08958de2e0\u0026amp;gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: \u0026lt;/p\u0026gt; ` Approfondendo la ricerca si artriva a tale indicazione :::caution The issue seems to be related to the fact that block.value.rows is a generator object. In Python, generators are lazy and can be consumed only once. If you try to iterate through the generator more than once, you will get an empty result on subsequent iterations.\nIn your case, it seems like the generator has been consumed once, which is why when you try to access block.value.rows.1, it doesn\u0026rsquo;t contain any values.\nTo address this issue, you might want to convert the generator to a list so that you can iterate through it multiple times. However, since you are using the TypedTableBlock from wagtail.contrib.typed_table_block, you might need to adjust how you access the rows.\nHere is a modification that converts the generator to a list before using it:\ndjango Copy code\n\u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: {{ block.value.rows|list }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: {{ block.value.rows|list.1|default:\u0026quot;\u0026quot; }}\u0026lt;/p\u0026gt; {% with block.value.rows|list.1|default:\u0026quot;\u0026quot; as row_values %} {{ row_values.0|default:\u0026quot;\u0026quot; }} {% endwith %} \u0026lt;/th\u0026gt; {% endfor %} \u0026lt;/tr\u0026gt; WAGTAIL Upgrade process We recommend upgrading one feature release at a time, even if your project is several versions behind the current one. This has a number of advantages over skipping directly to the newest release:\nIf anything breaks as a result of the upgrade, you will know which version caused it, and will be able to troubleshoot accordingly;\nDeprecation warnings shown in the console output will notify you of any code changes you need to make before upgrading to the following version;\nSome releases make database schema changes that need to be reflected on your project by running ./manage.py makemigrations - this is liable to fail if too many schema changes happen in one go.\nBefore upgrading to a new feature release:\nCheck your project’s console output for any deprecation warnings, and fix them where necessary;\nCheck the new version’s release notes, and the Compatible Django / Python versions table below, for any dependencies that need upgrading first;\nMake a backup of your database.\nTo upgrade:\nUpdate the wagtail line in your project’s requirements.txt file to specify the latest patch release of the version you wish to install. For example, to upgrade to version 1.8.x, the line should read: `wagtail\u0026gt;=1.8,\u0026lt;1.9 Run:\npip install -r requirements.txt ./manage.py makemigrations ./manage.py migrate`\nMake any necessary code changes as directed in the “Upgrade considerations” section of the release notes.\nTest that your project is working as expected.\nRemember that the JavaScript and CSS files used in the Wagtail admin may have changed between releases - if you encounter erratic behaviour on upgrading, ensure that you have cleared your browser cache. When deploying the upgrade to a production server, be sure to run ./manage.py collectstatic to make the updated static files available to the web server. In production, we recommend enabling ManifestStaticFilesStorage in the STATICFILES_STORAGE setting - this ensures that different versions of files are assigned distinct URLs.\nWAGTAIL COMPATIBILITY WITH DJANGO - link PYTHON Spiegazione attraverso codice di init, getattribute e super Spesso nei moduli di wagtail si fa riferimento alla classazione e subclassazione. Avere chiri alcuni termini è necessario. Questa è la breve sintesi attraverso un sempio\nclass Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;)` This is a simple class representing a vehicle with a brand. It has an init method that initializes the brand attribute and a start method to print a message when the vehicle starts. Car (inherits from Vehicle):\npython Copy code class Car(Vehicle): def init(self, brand, model): # No use of super() ​ self.model = model\ndef start(self): print(f\u0026quot;{self.brand} {self.model} car started.\u0026quot;) This class represents a specific type of vehicle, a Car, inheriting from the Vehicle class. It has its own init method, but it doesn\u0026rsquo;t use super(), and it has a start method that overrides the start method in the Vehicle class. CarWithSuper (inherits from Car):\nclass CarWithSuper(Car): def init(self, brand, model, color): super().init(brand, model) self.color = color\ndef start(self): super().start() print(f\u0026quot;The {self.color} car is ready to go.\u0026quot;) def __getattribute__(self, name): # Modifying __getattribute__ to add a prefix to the brand attribute if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__(name) else: return super().__getattribute__(name) This class inherits from Car and introduces a new attribute color. It uses super() in the init method to call the init method of the parent class (Car). It overrides the start method, calls the parent\u0026rsquo;s start method using super(), and adds an additional message. It also modifies getattribute to add a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the brand attribute. Examples: Example without super(), init, and getattribute:\ncar_without_super = Car(brand=\u0026quot;Toyota\u0026quot;, model=\u0026quot;Camry\u0026quot;) print(car_without_super.model) # Output: Camry An instance of Car is created without using super(). __init__ in Car is called, but __init__ of the parent (Vehicle) is not called. start method from Vehicle is not available in car_without_super. Example with super(), __init__, and __getattribute__: car_with_super = CarWithSuper(brand=\u0026quot;Ford\u0026quot;, model=\u0026quot;Mustang\u0026quot;, color=\u0026quot;red\u0026quot;) print(car_with_super.brand) # Output: Awesome Ford car_with_super.start() # Output: Ford Mustang car started. The red car is ready to go.\nAn instance of CarWithSuper is created using super() to call init of the parent (Car). getattribute is modified to add a prefix to the brand attribute. start method calls the parent\u0026rsquo;s (Car) start method using super() and adds an additional message. Roles:\ninit: Used for initializing the attributes of an object. In the inheritance chain, it\u0026rsquo;s common to use super().init(\u0026hellip;) to call the initializer of the parent class.\ngetattribute: Called whenever an attribute of an object is accessed. Can be modified to customize attribute access. Used here to modify the behavior of accessing the brand attribute.\nsuper(): Used to refer to the parent class. In init, it\u0026rsquo;s used to call the initializer of the parent class. In methods, it\u0026rsquo;s used to call methods from the parent class. In the provided example, super() helps maintain the hierarchy in inheritance, ensuring that the methods of the parent classes are appropriately called. init is used for object initialization, and getattribute is modified to customize attribute access.\nVediamo ora cosa succede se non utilizziamo i metodi Assenza di init If you don\u0026rsquo;t use the init method in the Vehicle class, the class will still be valid, but instances of the class won\u0026rsquo;t have a constructor to initialize their state. The init method is a special method in Python classes that is automatically called when an object is created. It is used for initializing the attributes of the object.\nHere\u0026rsquo;s what happens when you don\u0026rsquo;t include init:\npython Copy code class Vehicle: def start(self): print(\u0026ldquo;Vehicle started.\u0026rdquo;)\nCreating an instance without init vehicle_instance = Vehicle()\nThis will not raise an error, but the instance won\u0026rsquo;t have a \u0026lsquo;brand\u0026rsquo; attribute. If you try to access \u0026lsquo;brand\u0026rsquo;, it will result in an AttributeError. print(vehicle_instance.start()) # Output: Vehicle started. print(vehicle_instance.brand) # AttributeError: \u0026lsquo;Vehicle\u0026rsquo; object has no attribute \u0026lsquo;brand\u0026rsquo; In the example above, creating an instance of Vehicle without an init method is allowed. However, without an init method, instances won\u0026rsquo;t have any attributes initialized during instantiation. If you try to access an attribute that hasn\u0026rsquo;t been defined, you will get an AttributeError.\nIncluding the init method allows you to initialize the state of an object when it is created. For example:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) Creating an instance with init vehicle_instance = Vehicle(brand=\u0026ldquo;Toyota\u0026rdquo;)\nNow, the 'brand' attribute is initialized during instantiation. print(vehicle_instance.start()) # Output: Toyota vehicle started. print(vehicle_instance.brand) # Output: Toyota In the second example, the init method is used to initialize the brand attribute when a Vehicle instance is created. This ensures that the instance has a properly initialized state from the beginning.\nEd ora quando posso usare e non usare getattribute? If you don\u0026rsquo;t define the getattribute method in a class, Python will use the default behavior for attribute access. The default behavior involves looking up the attribute in the object\u0026rsquo;s dictionary and returning its value if found. If the attribute is not found in the object\u0026rsquo;s dictionary, Python looks for the attribute in the class hierarchy.\nHere\u0026rsquo;s what happens if you don\u0026rsquo;t use getattribute:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) Creating an instance without getattribute vehicle_instance = Vehicle(brand=\u0026ldquo;Toyota\u0026rdquo;)\nAccessing the \u0026lsquo;brand\u0026rsquo; attribute without a custom getattribute print(vehicle_instance.brand) # Output: Toyota\nThe default behavior is used, and there is no need for a custom getattribute in this case. In the example above, we create a Vehicle class with an init method to initialize the brand attribute. When we access the brand attribute, the default attribute access behavior is used, and there is no need for a custom getattribute. The attribute is found in the instance\u0026rsquo;s dictionary, and its value is returned.\nThe getattribute method is a powerful tool for customizing attribute access, and it allows you to intercept attribute access calls and customize the behavior. However, in many cases, you may not need to override it, and the default behavior is sufficient for basic attribute access. Only when you need to customize the attribute access behavior should you consider defining a getattribute method.\nIn the example provided, the getattribute method is used to customize the behavior of accessing the brand attribute in the CarWithSuper class. Specifically, it adds a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the value of the brand attribute before returning it.\nHere\u0026rsquo;s the relevant part of the code:\npython Copy code class CarWithSuper(Car): # \u0026hellip;\ndef __getattribute__(self, name): # Modifying __getattribute__ to add a prefix to the brand attribute if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__(name) else: return super().__getattribute__(name) In this case, the getattribute method is modifying the behavior of accessing the brand attribute. Without this customization, accessing car_with_super.brand would simply return the value of the brand attribute. With the custom getattribute, it returns the value with the added prefix.\nSo, you might need to use getattribute when you want to customize or intercept attribute access calls and modify the behavior based on your specific requirements. It\u0026rsquo;s a powerful tool, but it should be used judiciously, as unnecessary or incorrect use may lead to unexpected behavior and potential issues.\nMIXIN L\u0026rsquo;esempio esposto e che di seguito si ripropone risulta anche un ottimo esempio di mixin\nYes, the provided example with Vehicle, Car, and CarWithSuper can be considered an example of mixin-like behavior. Let me break it down:\nVehicle Class:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) This is the base class representing a generic vehicle. It has an init method to initialize the brand attribute and a start method.\nCar Class (Inherits from Vehicle):\npython Copy code class Car(Vehicle): def init(self, brand, model): super().init(brand) self.model = model\ndef start(self): print(f\u0026quot;{self.brand} {self.model} car started.\u0026quot;) The Car class inherits from Vehicle. It has its own init method but uses super() to call the init method of the parent class (Vehicle). It also has its own start method, overriding the start method of Vehicle.\nCarWithSuper Class (Inherits from Car):\npython Copy code class CarWithSuper(Car): def init(self, brand, model, color): super().init(brand, model) self.color = color\ndef start(self): super().start() print(f\u0026quot;The {self.color} car is ready to go.\u0026quot;) def __getattribute__(self, name): if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__('brand') else: return super().__getattribute__(name) The CarWithSuper class inherits from Car and introduces a new attribute (color). It uses super() to call the init method of the parent class (Car). It also overrides the start method, calling the parent\u0026rsquo;s (Car) start method using super() and adding an additional message. Additionally, it modifies getattribute to add a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the brand attribute.\nSo, in this example, the classes are organized in a way that exhibits mixin-like behavior. The CarWithSuper class enhances the behavior of the Car class by adding attributes and modifying methods, and it uses super() to maintain the hierarchy and call methods from parent classes. While it may not strictly adhere to the classic definition of a mixin, it shares some characteristics of mixin-like behavior.\nDefinizione di mixin In object-oriented programming, a mixin is a class that provides a certain functionality to be inherited by a subclass, but is not meant to stand alone. Mixins are used to enhance the functionality of a class without the need for multiple inheritance.\nHere are some key characteristics and features of mixins:\nPurpose-Specific Functionality: Mixins are designed to provide a specific set of functionalities or behaviors that can be easily added to other classes. They encapsulate a piece of behavior.\nReusability: Mixins promote code reuse. Instead of duplicating code in multiple classes, you can create a mixin and include it in various classes that need that particular behavior.\nNo Standalone Use: Mixins are not meant to be instantiated or used independently. They lack the complete implementation to be used as standalone classes. They are intended to be combined with other classes.\nFlexible Composition: Since a class can inherit from multiple mixins, it allows for flexible composition of functionalities. This is in contrast to languages that do not support multiple inheritance directly.\nAvoids Diamond Problem: Mixins can help avoid the \u0026ldquo;diamond problem\u0026rdquo; that arises in languages with multiple inheritance, where a class inherits from two classes that have a common ancestor.\nSmall and Focused: Mixins are typically small and focused on a specific task. This makes them easy to understand, maintain, and reuse.\nSTANDARD COMMANDS IN DJANGO INSTALLATION# python3 -m venv venv USEFUL PROPERTY AND METHOD IN DJANGO L\u0026rsquo;uso di Queryset Django querysets have several notable properties and methods that provide flexibility and ease of use when interacting with the database. Here are some key properties and methods of querysets:\nChaining:\nQuerysets are lazy, meaning they don\u0026rsquo;t hit the database until an action is performed. Multiple filters and operations can be chained together to build complex queries. Example:\npython Copy code queryset = Model.objects.filter(field1=value1).exclude(field2=value2).order_by(\u0026rsquo;-date_created\u0026rsquo;) Slicing:\nQuerysets can be sliced to retrieve a specific range of objects. Example:\npython Copy code queryset = Model.objects.all() result_slice = queryset[5:10] # Retrieve objects 5 through 9 Count:\nThe count method returns the number of objects in the queryset without fetching the actual objects. Example:\npython Copy code count = queryset.count() Distinct:\nThe distinct method eliminates duplicate rows from the queryset. Example:\npython Copy code distinct_values = Model.objects.values(\u0026lsquo;field\u0026rsquo;).distinct() Aggregate:\nThe aggregate method allows for the calculation of aggregate values (e.g., sum, average) on the queryset. Example:\npython Copy code from django.db.models import Avg average_value = Model.objects.aggregate(avg_value=Avg(\u0026rsquo;numeric_field\u0026rsquo;)) Values and ValuesList:\nThe values method returns a queryset of dictionaries representing the values of specific fields. The values_list method returns a queryset of tuples representing the values of specific fields. Example:\npython Copy code values_queryset = Model.objects.values(\u0026lsquo;field1\u0026rsquo;, \u0026lsquo;field2\u0026rsquo;) values_list_queryset = Model.objects.values_list(\u0026lsquo;field1\u0026rsquo;, \u0026lsquo;field2\u0026rsquo;) Exists:\nThe exists method checks if there are any records in the queryset. Example:\nqueryset_exists = Model.objects.filter(field=value).exists() Update and Delete:\nThe update method modifies multiple records in the database without fetching them. The delete method deletes records from the database without fetching them. Example:\npython Copy code Model.objects.filter(field=value).update(status=\u0026lsquo;new_status\u0026rsquo;) Model.objects.filter(field=value).delete() These are just a few of the many properties and methods provided by Django querysets. They offer a powerful and expressive way to interact with the database.\nEsempio in wagtail from datetime import datetime, timedelta, timezone from django.shortcuts import render from wagtail.core.models import Page from your_app.models import RoundPage # Replace \u0026lsquo;your_app\u0026rsquo; with the actual name of your app from path.to.get_deadline_date_for import get_deadline_date_for # Replace \u0026lsquo;path.to\u0026rsquo; with the actual path\ndef docs_internship(request): now = datetime.now(timezone.utc) today = get_deadline_date_for(now) five_weeks_ago = today - timedelta(days=7 * 5)\napplicant_round = RoundPage.objects.filter( pingnew__lte=today, internannounce__gt=today, ).first() intern_round = RoundPage.objects.filter( internannounce__lte=today, internends__gt=five_weeks_ago, ).first() return render(request, 'home/docs/internship_guide.html', { 'applicant_round': applicant_round, 'intern_round': intern_round, }) GIT \u0026amp; GITHUB Riferimenti Mastering MarkDown\nRicordarsi di aggiungere .gitgnore - git add .gitignore - git commit -m \u0026ldquo;Add .gitignore to exclude compiled Python files\u0026rdquo;\nPer effettuare il push da origine a remoto - git push origin implementazione-pagina\nSwitch to the New Branch: - git checkout new-branch-name\nCreare una nuova branch e posizionarsi sulla stessa - git checkout -b new-branch-name Il comando può essere visto come la sintesi dei due seguenti comandi: - git branch new-branch-name # Create a new branch - git checkout new-branch-name # Switch to the new branch\nYou\u0026rsquo;ve created a new branch (template-tutorial) without committing changes on your existing branch (implementazione-pagina) To address this, you\u0026rsquo;ll need to follow these steps to commit your changes on the implementazione-pagina branch and then switch back to the template-tutorial branch. Here\u0026rsquo;s a step-by-step guide:\nCommit Changes on implementazione-pagina: Assuming you are currently on the template-tutorial branch, ** switch back to the implementazione-pagina branch:** git checkout implementazione-pagina\nNow, add and commit your changes:\ngit add . git commit -m \u0026quot;Your commit message here\u0026quot;\nPush Changes to Remote (implementazione-pagina): Assuming the remote branch is named implementazione-pagina: git push origin implementazione-pagina\n** Switch Back to template-tutorial:** Now, switch back to the template-tutorial branch: git checkout template-tutorial\n*** If you haven\u0026rsquo;t pushed the template-tutorial branch yet, you can push it to the remote repository when you\u0026rsquo;re ready:***\ngit push origin template-tutorial\n*** How can see from my vsc local if a git branch is present also in the remote github? ***\ngit fetch --all git branch -a This fetches all branches from the remote repository and lists both local and remote branches. Remote branches are prefixed with \u0026ldquo;remotes/origin/\u0026rdquo;. Check if your branch is listed among the remotes.\n*** Come posso creare una nuova branch in local, e poi crearla anche in Github, poi effettuare il push e rendere questa branch principale? ***\nCreate a new branch locally and switch to it (chimiamo la nuova branch template-tutorial): git checkout -b template-tutorial\nPush the new branch to GitHub - *** If you want to make sure that the new branch on GitHub exactly matches your local branch, you can use the -u (or \u0026ndash;set-upstream) option when pushing for the first time ***\ngit push -u origin template-tutorial\nSet the upstream for the new branch:\ngit branch --set-upstream-to=origin/template-tutorial template-tutorial![alt]( \u0026lsquo;{\u0026ldquo;class\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;title\u0026rdquo;: \u0026ldquo;\u0026rdquo;}\u0026rsquo;)\nNow, further pushes can be simplified to:\ngit push\nTo revert the changes and go back to the original commit before the changes, you can use the following commands: git reset --hard HEAD git clean -fd\nThe first command (git reset \u0026ndash;hard HEAD) resets your branch to the latest commit, discarding changes. The second command (git clean -fd) removes untracked files and directories. Use them with caution, as they are not reversible.\n-fd stands for what? In the context of the git clean command:\n-f stands for force. -d stands for directory. Together, -fd means force removal of untracked directories. This option is used to remove untracked files and directories forcefully.\ndelete a local branch and also delete it on the remote repository on GitHub Delete the local branch:\ngit branch -d branch_name![alt]( \u0026lsquo;{\u0026ldquo;class\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;title\u0026rdquo;: \u0026ldquo;\u0026rdquo;}\u0026rsquo;)\nReplace branch_name with the name of the branch you want to delete.\nIf the branch contains unmerged changes, you might need to force delete it:\ngit branch -D branch_name\nDelete the remote branch:\ngit push origin --delete branch_name\nThis will delete the branch on the remote repository (GitHub).\nUpdate your local repository to reflect the changes on the remote:\ngit fetch --prune\nThe \u0026ndash;prune flag removes any remote tracking branches that no longer exist on the remote.\nI want to synch another an oldest branch named \u0026ldquo;template-tutorial\u0026rdquo; with a newest branch named template-sheetlike and after delete this last one (template-sheetlike) Switch to the template-tutorial branch: git switch template-tutorial\nRebase template-sheetlike onto template-tutorial: git rebase template-sheetlike\nPush the changes to the remote repository: git push origin template-tutorial --force Note: Force-pushing after a rebase rewrites the commit history. Use it with caution, especially if the branch has already been shared with others\nDelete the template-sheetlike branch: git branch -d template-sheetlike git push origin --delete template-sheetlike\nsome useful notes Merge: Creates Merge Commits: When you merge one branch into another, Git creates a new merge commit that has two parent commits: one from the branch you\u0026rsquo;re merging and another from the branch you\u0026rsquo;re merging into. This results in a non-linear history with multiple branches merging into each other Preserves Original History:\nThe original commits from both branches remain unchanged. This approach keeps a clear record of when changes were made on each branch.\nRebase: Linearizes History:\nRebase is used to linearize the commit history. It moves or combines a sequence of commits to a new base commit. When you rebase one branch onto another, it effectively transplants the entire branch onto the tip of the other branch, creating a linear history. No Merge Commits:\nUnlike merge, rebase doesn\u0026rsquo;t create additional merge commits. It can result in a cleaner, more linear history. When to Choose Each Approach:\nMerge: Use merge when you want to preserve the original commit history, especially when collaborating with others. Good for feature branches and when you want to maintain a clear record of branch integration points. Rebase:\nUse rebase when you want a clean, linear history and don\u0026rsquo;t mind rewriting commits. Useful for feature branches before merging into a shared branch to avoid unnecessary merge commits. Switch vs. Checkout: git switch is a more modern and user-friendly command introduced in recent versions of Git. It is designed specifically for branch switching. If you\u0026rsquo;re using a version of Git that supports git switch, you can replace git checkout with git switch:\nSwitching Branch: git switch template-tutorial Both commands essentially do the same thing in this context, but git switch provides a clearer and more explicit syntax for branch-related operations. If your Git version supports it, feel free to use git switch instead of git checkout.\nYAML PROTOCOL YAML (YAML Ain\u0026rsquo;t Markup Language) is a human-readable data serialization format that is often used for configuration files and data exchange between languages with different data structures. In a YAML file, indentation is crucial, as it determines the structure of the data. Here are some details on writing YAML files:\n1. Indentation: YAML uses indentation to represent the structure of the data. Spaces are recommended for indentation (not tabs), and the number of spaces is significant. Typically, two spaces or four spaces are used for each level of indentation. codekey1: key2: value key3: - item1 - item2 2. Key-Value Pairs: YAML uses a simple key-value format. Keys and values are separated by a colon, and the key-value pair is represented on a new line. codename: John Doe age: 30 3. Lists: Lists are represented using a hyphen followed by a space (- ). Lists can contain any combination of values, and each item is indented under the list key. codefruits: - apple - banana - orange 4. Dictionaries (Mappings): Dictionaries or mappings are represented using key-value pairs, and the key-value pairs are indented under the dictionary key. name: John Doe age: 30 5. Strings: Strings can be written without quotes. However, quotes are used when a string contains special characters or reserved words. message: Hello, World! 6. Multiline Strings: Multiline strings can be represented using the | or \u0026gt; characters. The | preserves newlines, while \u0026gt; folds newlines. codemultiline: | This is a multiline string in YAML. 7. Comments: Comments start with the # character and continue to the end of the line. code# This is a comment key: value 8. Anchors and Aliases: YAML supports anchors (\u0026amp;) and aliases (*) for creating references to the same data in multiple places. codefirst: \u0026amp;anchor_name John Doe second: *anchor_name These are some basic conventions for writing YAML files. Ensure that you are consistent with indentation, use proper syntax for key-value pairs, lists, and dictionaries, and pay attention to the structure of your YAML documents. Many programming languages and tools use YAML, and understanding its syntax is beneficial for working with various configurations and data files.\nWAGTAIL How to use StreamField for mixed content StreamField block reference Templating - Jinja Wrinting Templates La regola da seguire è questa:\ncode: class wagtail.fields.StreamField(blocks, use_json_field=None, blank=False, min_num=None, max_num=None, block_counts=None, collapsed=False)\nE questa la spiegazione:\nclass wagtail.fields.StreamField: This line defines a class named StreamField in the wagtail.fields module.\n(blocks, use_json_field=None, blank=False, min_num=None, max_num=None, block_counts=None, collapsed=False): These are the parameters that the StreamField class constructor (init method) accepts. Let\u0026rsquo;s go through each one:\nblocks: This is a required parameter. It represents the blocks that can be used in the stream. It seems like it should be provided when creating an instance of StreamField.\nuse_json_field=None: This is an optional parameter with a default value of None. It allows you to specify whether to use a JSON field for storage. If not provided, it defaults to None.\nblank=False: This is an optional parameter with a default value of False. It indicates whether the field is allowed to be blank when used in a form. If not provided, it defaults to False.\nmin_num=None: This is an optional parameter with a default value of None. It specifies the minimum number of blocks required. If not provided, it defaults to None.\nmax_num=None: This is an optional parameter with a default value of None. It specifies the maximum number of blocks allowed. If not provided, it defaults to None.\nblock_counts=None: This is an optional parameter with a default value of None. It seems related to counting blocks. If not provided, it defaults to None.\ncollapsed=False: This is an optional parameter with a default value of False. It indicates whether the blocks should be collapsed in the Wagtail admin interface. If not provided, it defaults to False\nCosì ad esempio per questo codice. Possiamo effettuare il breakdown di questo codice in base alla regola definita:\n`class BlogPage(Page): author = models.CharField(max_length=255, default=\u0026lsquo;Default Author\u0026rsquo;) date = models.DateField(\u0026ldquo;Post date\u0026rdquo;)\nbody = StreamField( [ ('heading', blocks.CharBlock(form_classname=\u0026quot;title\u0026quot;)), ('paragraph', blocks.RichTextBlock()), ('image', ImageChooserBlock()), ('code', CodeBlock()), ('raw_html', RawHTMLBlock()), ], use_json_field=True ) content_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('body'), ] `\nauthor = models.CharField(max_length=255, default=\u0026lsquo;Default Author\u0026rsquo;): This line defines a character field named author in the BlogPage class. It has a maximum length of 255 characters and a default value of \u0026lsquo;Default Author\u0026rsquo;.\ndate = models.DateField(\u0026ldquo;Post date\u0026rdquo;): This line defines a date field named date in the BlogPage class with a human-readable name \u0026ldquo;Post date\u0026rdquo;.\nbody = StreamField([\u0026hellip;], use_json_field=True): This line defines a stream field named body in the BlogPage class. It allows the inclusion of different block types, such as CharBlock, RichTextBlock, ImageChooserBlock, CodeBlock, and RawHTMLBlock. The use_json_field parameter is set to True, indicating that a JSON field will be used for storage.\ncontent_panels = Page.content_panels + [\u0026hellip;]: This line defines the content panels for the Wagtail admin interface. It includes panels for \u0026lsquo;author\u0026rsquo;, \u0026lsquo;date\u0026rsquo;, and \u0026lsquo;body\u0026rsquo;.\nPoi in particolare:\ncontent_panels definition in the BlogPage class:#### content_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('body'), ]\nPage.content_panels: This part includes the content panels defined in the parent Page class. It allows the inclusion of standard page fields, such as title, slug, publish date, etc.\nFieldPanel(\u0026lsquo;author\u0026rsquo;): This adds a panel for the author field to the content panels. It\u0026rsquo;s likely a simple text input for the author\u0026rsquo;s name.\nFieldPanel(\u0026lsquo;date\u0026rsquo;): This adds a panel for the date field, probably a date picker for selecting the post date.\nFieldPanel(\u0026lsquo;body\u0026rsquo;): This adds a panel for the body field. Since it\u0026rsquo;s a StreamField, it might include a dynamic set of blocks like headings, paragraphs, images, code blocks, and raw HTML.\nUso dello StructBox in Wagtail Example Model with StructBlock Consider a simple model for a page with a StreamField containing a StructBlock named \u0026lsquo;person\u0026rsquo;:\n` # models.py from django.db import models from wagtail.core.fields import StreamField from wagtail.core import blocks from wagtail.images.blocks import ImageChooserBlock from wagtail.core.models import Page from wagtail.admin.edit_handlers import FieldPanel, StreamFieldPanel\nclass BlogPage(Page): body = StreamField([ (\u0026lsquo;person\u0026rsquo;, blocks.StructBlock([ (\u0026lsquo;first_name\u0026rsquo;, blocks.CharBlock()), (\u0026lsquo;surname\u0026rsquo;, blocks.CharBlock()), (\u0026lsquo;photo\u0026rsquo;, ImageChooserBlock(required=False)), (\u0026lsquo;biography\u0026rsquo;, blocks.RichTextBlock()), ])), (\u0026lsquo;heading\u0026rsquo;, blocks.CharBlock(form_classname=\u0026ldquo;title\u0026rdquo;)), (\u0026lsquo;paragraph\u0026rsquo;, blocks.RichTextBlock()), (\u0026lsquo;image\u0026rsquo;, ImageChooserBlock()), ], use_json_field=True)\ncontent_panels = Page.content_panels + [ StreamFieldPanel('body'), ] `\u0026lt;/span\u0026gt; Diagram Explanation Blog Page with StreamField and StructBlock:\nA BlogPage contains a StreamField named \u0026lsquo;body\u0026rsquo;. \u0026lsquo;body\u0026rsquo; includes various block types, one of which is a StructBlock named \u0026lsquo;person\u0026rsquo;. Person StructBlock:\nThe \u0026lsquo;person\u0026rsquo; block is a StructBlock containing fields like \u0026lsquo;first_name\u0026rsquo;, \u0026lsquo;surname\u0026rsquo;, \u0026lsquo;photo\u0026rsquo;, and \u0026lsquo;biography\u0026rsquo;. Block Instances:\nWhen editing a BlogPage, you can add multiple instances of different block types, including \u0026lsquo;person\u0026rsquo;. Each \u0026lsquo;person\u0026rsquo; block instance can have its own \u0026lsquo;first_name\u0026rsquo;, \u0026lsquo;surname\u0026rsquo;, \u0026lsquo;photo\u0026rsquo;, and \u0026lsquo;biography\u0026rsquo;\nTemplate Implementation\nTo render this in a template, you can use the following:\n`\u0026lt;!-- templates/blog_page.html --\u0026gt; {% extends \u0026#34;base.html\u0026#34; %} {% block content %} \u0026lt;article\u0026gt; {% for block in page.body %} {% if block.block_type == \u0026#39;person\u0026#39; %} \u0026lt;div class=\u0026#34;person\u0026#34;\u0026gt; {% if block.value.photo %} {% image block.value.photo width-400 %} {% endif %} \u0026lt;h2\u0026gt;{{ block.value.first_name }} {{ block.value.surname }}\u0026lt;/h2\u0026gt; {{ block.value.biography }} \u0026lt;/div\u0026gt; {% else %} {# Rendering for other block types #} \u0026lt;section class=\u0026#34;{{ block.block_type }}\u0026#34;\u0026gt; {% include_block block %} \u0026lt;/section\u0026gt; {% endif %} {% endfor %} \u0026lt;/article\u0026gt; {% endblock %} Database Initialization\nWhen you run makemigrations and migrate after adding the StructBlock to your model, the necessary database tables and fields are created. The use_json_field=True parameter in the StreamField indicates that the data for the StreamField will be stored as JSON in the database.\nHere\u0026rsquo;s how you perform the migration:\nbash Copy code python manage.py makemigrations python manage.py migrate After migration, you can create or edit a BlogPage instance through the Wagtail admin interface. The StructBlock fields will be part of the form for each \u0026lsquo;person\u0026rsquo; block within the \u0026lsquo;body\u0026rsquo; StreamField.\nRiferimenti Rapidi Wagtail Caso Studio web page\nHow to use Streamfield for mixed content\nStreamFieldBlock Reference\nCaratteristiche avanzate di Diango - Wagtail Uno dei porblemi che si incontrano effettuando delle tabelle all\u0026rsquo;interno di wagtail ma in generale anche in Django è il caso pratico della renderizzazione degli headers di una tabella se si vogliono recuperare ad esempio i dati all\u0026rsquo;interno delle celle della tabella.\nAttenzione!: questo progetto è illustrato al solo fine didattico. Infatti nell\u0026rsquo;applicazione concreta vi sono notevoli problemi nell\u0026rsquo;effettuare il passaggio dei dati da Django a Wagtail. Per cui ai fini applicativi la via migliore per rendere i dati da Django a Wagtail è quella della costruzione di un API attraverso serializer (vedere capitolo)\nQuesto codice di esempio effettua il debug su ciò che è successo:\n` {% for column in block.value.columns %} {{ column.header|default:\u0026ldquo;Column Header\u0026rdquo; }}\n\u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: {{ block.value.rows|list }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: {{ block.value.rows|list.1|default:\u0026quot;\u0026quot; }}\u0026lt;/p\u0026gt; {% with block.value.rows|list.1|default:\u0026quot;\u0026quot; as row_values %} {{ row_values.0|default:\u0026quot;\u0026quot; }} {% endwith %} \u0026lt;/th\u0026gt; {% endfor %} \u0026lt;/tr\u0026gt; \u0026lt;th\u0026gt; Column Header \u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: \u0026amp;lt;generator object TypedTable.rows at 0x7f08958de2e0\u0026amp;gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: \u0026lt;/p\u0026gt; ` Approfondendo la ricerca si artriva a tale indicazione :::caution The issue seems to be related to the fact that block.value.rows is a generator object. In Python, generators are lazy and can be consumed only once. If you try to iterate through the generator more than once, you will get an empty result on subsequent iterations.\nIn your case, it seems like the generator has been consumed once, which is why when you try to access block.value.rows.1, it doesn\u0026rsquo;t contain any values.\nTo address this issue, you might want to convert the generator to a list so that you can iterate through it multiple times. However, since you are using the TypedTableBlock from wagtail.contrib.typed_table_block, you might need to adjust how you access the rows.\nHere is a modification that converts the generator to a list before using it:\ndjango Copy code\n\u0026lt;!-- Debugging statements --\u0026gt; \u0026lt;p\u0026gt;block.value.rows: {{ block.value.rows|list }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;block.value.rows.1: {{ block.value.rows|list.1|default:\u0026quot;\u0026quot; }}\u0026lt;/p\u0026gt; {% with block.value.rows|list.1|default:\u0026quot;\u0026quot; as row_values %} {{ row_values.0|default:\u0026quot;\u0026quot; }} {% endwith %} \u0026lt;/th\u0026gt; {% endfor %} \u0026lt;/tr\u0026gt; HOW TO FEED A TABLE FROM DJANGO ADMIN PANEL, OPEN IN AS BLOCK INTO WAGTAIL ADMIN PANEL AND RENDER IT INTO THE WAGTAIL FRONTEND Premessa: prima di effettuare questa complessa operazione va tenuto in conto che i due progetti uno django e l\u0026rsquo;altro wagtail derivano da due repository differenti. Quindi il problema iniziale sarà quello di renedere omogenei i file .git. Per fare ciò dunque di seguito si descrive il metodo migliore individuato:\nIf you want to consolidate both the Django and Wagtail projects into a single Git repository, and you\u0026rsquo;ve already initialized separate repositories in each project\u0026rsquo;s directory, you have a couple of options:\nOption 1: Delete Existing Git Repositories\nDelete Git repositories in directory and subdirectories:\nNavigate to each subdirectory (e.g., django_general_template2 and blog_wiki_wag/blog_page_wiki_wag/wiki-wag) containing a Git repository. Run rm -rf .git to delete the existing Git repository. Initialize a new Git repository in the root directory:\nRun cd /path/to/django_general_template2 (replace /path/to/django_general_template2 with your actual path). Run git init to initialize a new Git repository. Add, commit, and push:\nAdd all files with git add .. Commit the changes with git commit -m \u0026quot;Initial commit\u0026quot;. If you\u0026rsquo;ve already set up a remote repository, push the changes to it. Great! Since you\u0026rsquo;ve deleted the existing Git repositories and initialized a new one in the root directory, here are the steps to create a new GitHub repository (django-wiki-wag) and push your local changes to it:\nCreate a New GitHub Repository:\nGo to GitHub. Log in to your account. Click the \u0026ldquo;+\u0026rdquo; icon in the top right corner and select \u0026ldquo;New repository.\u0026rdquo; Fill in the repository name (e.g., django-wiki-wag), add a description if you want, and choose other repository settings. Click \u0026ldquo;Create repository.\u0026rdquo; Set the Remote Origin for Your Local Repository:\nIn your local terminal, navigate to the root directory of your project.\nRun the following commands, replacing the repository URL with your newly created repository URL:\nbashCopy code git remote add origin https://github.com/your-username/django-wiki-wag.git Add, Commit, and Push:\nRun the following commands to add all files, commit your changes, and push to GitHub:\nbashCopy codegit add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin main Note: Replace main with the name of the branch you are working on (it could be master or another branch).\nVerify on GitHub:\nVisit your GitHub repository (https://github.com/your-username/django-wiki-wag). Confirm that your files and project structure are visible. Now, your local project should be synchronized with the new GitHub repository. If you encounter any issues during the process, feel free to ask for further assistance!\nTo achieve your goal, you\u0026rsquo;ll need to follow a series of steps. I\u0026rsquo;ll provide you with a step-by-step guide to make the necessary changes and additions to your Django admin, Wagtail models, and HTML template.\nStep 1: Adjust Wagtail Settings\nIn the settings.py of your Wagtail project (wiki-wag), ensure that the ALLOWED_HOSTS setting includes the appropriate values for your Django project. Update other settings if needed.\npythonCopy code# wiki-wag/settings/base.py ALLOWED_HOSTS = [\u0026#39;yourdjangoapp.com\u0026#39;, \u0026#39;localhost\u0026#39;, \u0026#39;127.0.0.1\u0026#39;] Step 2: Add Wagtail settings to Django settings.py\nIn your Django project (`general_template 1), include the Wagtail settings by updating settings.py:\n\u0026#34;\u0026#34;\u0026#34; Django settings for general_template1 project. Generated by \u0026#39;django-admin startproject\u0026#39; using Django 4.2.2. For more information on this file, see https://docs.djangoproject.com/en/4.2/topics/settings/ For the full list of settings and their values, see https://docs.djangoproject.com/en/4.2/ref/settings/ \u0026#34;\u0026#34;\u0026#34; from pathlib import Path # Build paths inside the project like this: BASE_DIR / \u0026#39;subdir\u0026#39;. BASE_DIR = Path(__file__).resolve().parent.parent # Quick-start development settings - unsuitable for production # See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/ # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY = \u0026#39;django-insecure-2-yc!0z!mcv#w$3vk6#s5i635l+bg#x3+24w2!26ikg4o-dj4u\u0026#39; # SECURITY WARNING: don\u0026#39;t run with debug turned on in production! DEBUG = True # ALLOWED_HOSTS = [\u0026#39;127.0.0.1\u0026#39;, \u0026#39;localhost\u0026#39;, \u0026#39;146.190.169.21\u0026#39;] # tiene conto delle attività su droplet ALLOWED_HOSTS = [\u0026#39;app.sgbh.org\u0026#39;, \u0026#39;www.sgbh.org\u0026#39;, \u0026#39;127.0.0.1\u0026#39;, \u0026#39;localhost\u0026#39;, \u0026#39;146.190.169.21\u0026#39;] SECURE_PROXY_SSL_HEADER = (\u0026#39;HTTP_X_FORWARDED_PROTO\u0026#39;, \u0026#39;https\u0026#39;) # Application definition INSTALLED_APPS = [ \u0026#39;wagtail.contrib.forms\u0026#39;, \u0026#39;wagtail.contrib.redirects\u0026#39;, \u0026#39;wagtail.embeds\u0026#39;, \u0026#39;wagtail.sites\u0026#39;, \u0026#39;wagtail.users\u0026#39;, \u0026#39;wagtail.snippets\u0026#39;, \u0026#39;wagtail.documents\u0026#39;, \u0026#39;wagtail.images\u0026#39;, \u0026#39;wagtail.search\u0026#39;, \u0026#39;wagtail.admin\u0026#39;, \u0026#39;taggit\u0026#39;, \u0026#39;modelcluster\u0026#39;, \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;sgq\u0026#39;, \u0026#39;wagtail\u0026#39;, ] MIDDLEWARE = [ \u0026#39;django.middleware.security.SecurityMiddleware\u0026#39;, \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39;, \u0026#39;django.middleware.common.CommonMiddleware\u0026#39;, \u0026#39;django.middleware.csrf.CsrfViewMiddleware\u0026#39;, \u0026#39;django.contrib.auth.middleware.AuthenticationMiddleware\u0026#39;, \u0026#39;django.contrib.messages.middleware.MessageMiddleware\u0026#39;, \u0026#39;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026#39;, \u0026#39;wagtail.contrib.redirects.middleware.RedirectMiddleware\u0026#39;, ] ROOT_URLCONF = \u0026#39;general_template1.urls\u0026#39; TEMPLATES = [ { \u0026#39;BACKEND\u0026#39;: \u0026#39;django.template.backends.django.DjangoTemplates\u0026#39;, \u0026#39;DIRS\u0026#39;: [], \u0026#39;APP_DIRS\u0026#39;: True, \u0026#39;OPTIONS\u0026#39;: { \u0026#39;context_processors\u0026#39;: [ \u0026#39;django.template.context_processors.debug\u0026#39;, \u0026#39;django.template.context_processors.request\u0026#39;, \u0026#39;django.contrib.auth.context_processors.auth\u0026#39;, \u0026#39;django.contrib.messages.context_processors.messages\u0026#39;, ], }, }, ] WSGI_APPLICATION = \u0026#39;general_template1.wsgi.application\u0026#39; WSGI_SERVER_PORT = 443 # Database # https://docs.djangoproject.com/en/4.2/ref/settings/#databases DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#39;db.sqlite3\u0026#39;, } } # Password validation # https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators AUTH_PASSWORD_VALIDATORS = [ { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.UserAttributeSimilarityValidator\u0026#39;, }, { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.MinimumLengthValidator\u0026#39;, }, { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.CommonPasswordValidator\u0026#39;, }, { \u0026#39;NAME\u0026#39;: \u0026#39;django.contrib.auth.password_validation.NumericPasswordValidator\u0026#39;, }, ] # Internationalization # https://docs.djangoproject.com/en/4.2/topics/i18n/ LANGUAGE_CODE = \u0026#39;en-us\u0026#39; TIME_ZONE = \u0026#39;UTC\u0026#39; USE_I18N = True USE_TZ = True # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/4.2/howto/static-files/ STATIC_URL = \u0026#39;static/\u0026#39; # Default primary key field type # https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field DEFAULT_AUTO_FIELD = \u0026#39;django.db.models.BigAutoField\u0026#39; Step 3: Add Wagtail URLs to Django URLs\nIn your Django project (`general_template 1), include the Wagtail urls by updating urls.py:\nfrom django.contrib import admin from django.urls import path, include from wagtail import urls as wagtail_urls urlpatterns = [ path(\u0026#39;\u0026#39;, include(\u0026#39;sgq.urls\u0026#39;)), # Include the app-level URLs path(\u0026#39;admin/\u0026#39;, admin.site.urls), # path(\u0026#39;wagtail/\u0026#39;, include(\u0026#39;wagtail.core.urls\u0026#39;)), # nuovo inserimento path(\u0026#39;wagtail/\u0026#39;, include(wagtail_urls)), # nuovo inserimento ] **Step 4: Add a Fixed Table Block to Your Models **and Update BlogPage Model ** In your blog/models.py, add the FixedTableBlock to the list of available blocks. This block will represent the fixed table content. Include the FixedTableBlock in the StreamField of your BlogPage model.\nThe key changes here are adding the import for FixedTableBlock and including it in the StreamField under the name 'fixed_table'. from wagtail.images.blocks import ImageChooserBlock from wagtail.fields import StreamField, RichTextField from wagtail.admin.panels import FieldPanel from wagtail.documents.blocks import DocumentChooserBlock from wagtail.models import Page from wagtail import blocks from wagtail.contrib.table_block.blocks import TableBlock from wagtail.contrib.routable_page.models import RoutablePageMixin, path from django.db import models from wagtail.search import index from modelcluster.fields import ParentalKey from wagtail.contrib.forms.models import AbstractEmailForm, AbstractFormField from .blocks import PublicationBlock # rif 1 - Adding in rendering get_absolute_url from wagtail.contrib.typed_table_block.blocks import TypedTableBlock from wagtail.images.blocks import ImageChooserBlock class RawHTMLBlock(blocks.RawHTMLBlock): class Meta: icon = \u0026#34;code\u0026#34; # Set a suitable icon from available Wagtail icons template = \u0026#39;blog/raw_html_block.html\u0026#39; class CodeBlock(blocks.StructBlock): code = blocks.TextBlock() class Meta: template = \u0026#39;blog/code_block.html\u0026#39; class FixedTableBlock(blocks.StructBlock): fixed_table_text = blocks.CharBlock() class Meta: icon = \u0026#39;table\u0026#39; # Set an icon for the block template = \u0026#39;blog/fixed_table_block.html\u0026#39; # Create this template for rendering the block class BlogPage(Page): author = models.CharField(max_length=255, default=\u0026#39;Default Author\u0026#39;) date = models.DateField(\u0026#34;Post date\u0026#34;) # New field for content choice content_choice = models.CharField( max_length=20, choices=[ (\u0026#39;choice_one\u0026#39;, \u0026#39;Choice One\u0026#39;), (\u0026#39;choice_two\u0026#39;, \u0026#39;Choice Two\u0026#39;), ], default=\u0026#39;choice_one\u0026#39;, # Set a default choice help_text=\u0026#34;Select the content to be displayed on the page.\u0026#34; ) body = StreamField([ (\u0026#39;heading\u0026#39;, blocks.CharBlock(form_classname=\u0026#34;title\u0026#34;)), (\u0026#39;paragraph\u0026#39;, blocks.RichTextBlock()), (\u0026#39;image\u0026#39;, ImageChooserBlock()), (\u0026#39;code\u0026#39;, CodeBlock()), (\u0026#39;raw_html\u0026#39;, RawHTMLBlock()), (\u0026#39;publication\u0026#39;, PublicationBlock()), # rif 1 - Adding in rendering get_absolute_url (\u0026#39;table\u0026#39;, TypedTableBlock([ (\u0026#39;text\u0026#39;, blocks.CharBlock()), (\u0026#39;numeric\u0026#39;, blocks.FloatBlock()), (\u0026#39;rich_text\u0026#39;, blocks.RichTextBlock()), (\u0026#39;image\u0026#39;, ImageChooserBlock()), (\u0026#39;country\u0026#39;, blocks.ChoiceBlock(choices=[ (\u0026#39;be\u0026#39;, \u0026#39;Belgium\u0026#39;), (\u0026#39;fr\u0026#39;, \u0026#39;France\u0026#39;), (\u0026#39;de\u0026#39;, \u0026#39;Germany\u0026#39;), (\u0026#39;nl\u0026#39;, \u0026#39;Netherlands\u0026#39;), (\u0026#39;pl\u0026#39;, \u0026#39;Poland\u0026#39;), (\u0026#39;uk\u0026#39;, \u0026#39;United Kingdom\u0026#39;), ])), ])), (\u0026#39;fixed_table\u0026#39;, FixedTableBlock()), # Add the FixedTableBlock ], use_json_field=True) content_panels = Page.content_panels + [ FieldPanel(\u0026#39;author\u0026#39;), FieldPanel(\u0026#39;date\u0026#39;), FieldPanel(\u0026#39;content_choice\u0026#39;), FieldPanel(\u0026#39;body\u0026#39;), ] **Step 5: **Go in the Wagtail manage.py level and make sure to run migrations after making these changes:\npython3 manage.py makemigrations python3 manage.py migrate Now you can use the Wagtail admin to add and edit the content for the fixed_table block in your BlogPage. This content should then be rendered in your blog_page.html\nAt this stage you go into Wagtail Project via **python3 manage.py runserver ** into admin panel and if all works you can access and add the table. In the wagtail preview mode you receive a visualization error because the blog/fixed_table_block.html does not exists!\nStep 6 - Creation of blog/fixed_table_block.html\nSo before to jump to Django admin level to create an input data entry let\u0026rsquo;s try to enter the data from FixedTableBlock(). In this manner sure that all is working fine just until now. To do this First, update the FixedTableBlock in models.py:\npythonCopy codefrom wagtail.core import blocks class FixedTableBlock(blocks.StructBlock): nation = blocks.CharBlock(required=True, help_text=\u0026#39;Enter nation\u0026#39;) capital = blocks.CharBlock(required=True, help_text=\u0026#39;Enter capital\u0026#39;) class Meta: template = \u0026#39;blog/fixed_table_block.html\u0026#39; Then, create or update the template file at blog/templates/blog/fixed_table_block.html:\nhtmlCopy code\u0026lt;div\u0026gt; \u0026lt;table class=\u0026#34;table table-bordered table-striped\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Nation\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Capital\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;{{ value.nation }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ value.capital }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; Go in the Wagtail manage.py level and make sure to run migrations after making these changes:\npython3 manage.py makemigrations python3 manage.py migrate python3 manage.py migrate If all works you are able to input the data and see the table in Wagtail preview mode\nAlways remeber to conslidate you commmit pushing on Github\nStep 7 - Implementation models.py - Django side\nCreate a Django model for the content you want to manage:\nDefine a Django model in your models.py that represents the content you want to associate with the FixedTableBlock\npythonCopy code# models.py from django.db import models class FixedTableContent(models.Model): nation = models.CharField(max_length=255) capital = models.CharField(max_length=255) def __str__(self): return self.nation Step 8 - Implementation admin.py - Django side\nCreate an admin class for the new model:\nCreate an admin class for your new model in the admin.py file:\n# admin.py from django.contrib import admin from .models import FixedTableContent @admin.register(FixedTableContent) class FixedTableContentAdmin(admin.ModelAdmin): list_display = (\u0026#39;nation\u0026#39;, \u0026#39;capital\u0026#39;) This admin class will allow you to manage instances of FixedTableContent in the Django admin.\n\u0026mdash;\u0026mdash;\u0026mdash; FINO A QUI \u0026ndash;\ntemplate.Step 3: Create Template for FixedTableBlock Create a template file at blog/templates/blog/fixed_table_block.html for rendering the FixedTableBlock. This template will be used to display the fixed table content.\nhtml Copy code {{ value.fixed_table_text }} Step 4: Run Migrations Run the following commands to apply the model changes:\nbash Copy code python manage.py makemigrations python manage.py migrate Step 5: Update Django Admin Create an admin class for BlogPage in blog/wagtail_hooks.py:\npython Copy code from wagtail.contrib.modeladmin.options import ( ModelAdmin, modeladmin_register, ModelAdminGroup ) from .models import BlogPage\nclass BlogPageAdmin(ModelAdmin): model = BlogPage menu_label = \u0026lsquo;Blog Pages\u0026rsquo; menu_icon = \u0026lsquo;doc-full-inverse\u0026rsquo; menu_order = 200 add_to_settings_menu = False exclude_from_explorer = False list_display = (\u0026rsquo;title\u0026rsquo;, \u0026lsquo;author\u0026rsquo;, \u0026lsquo;date\u0026rsquo;, \u0026lsquo;content_choice\u0026rsquo;) search_fields = (\u0026rsquo;title\u0026rsquo;, \u0026lsquo;author\u0026rsquo;, \u0026lsquo;date\u0026rsquo;, \u0026lsquo;content_choice\u0026rsquo;)\nmodeladmin_register(BlogPageAdmin) Step 6: Include Admin CSS In your blog/static/css/admin.css file, add the following CSS to improve the display of the custom block in the admin.\ncss Copy code .wagtail-edit-handler-fixed_table .field-content textarea { height: 100px; /* Adjust the height as needed */ } Step 7: Update BlogPage Admin Panels Update the content_panels in BlogPage to include the new block:\npython Copy code\n\u0026hellip; class BlogPage(Page): # \u0026hellip;\ncontent_panels = Page.content_panels + [ FieldPanel('author'), FieldPanel('date'), FieldPanel('content_choice'), FieldPanel('body'), ] Step 8: Update blog_page.html Update blog/templates/blog/blog_page.html to render the new FixedTableBlock.\nhtml Copy code\n{% for block in page.body %} {% if block.block_type == \u0026lsquo;fixed_table\u0026rsquo; %} {% include_block block %} {% elif block.block_type == \u0026rsquo;table\u0026rsquo; %} {% elif block.block_type == \u0026lsquo;heading\u0026rsquo; %} {% elif block.block_type == \u0026lsquo;publication\u0026rsquo; %} {% else %} {% endif %} {% endfor %}\nStep 9: Restart Server Restart your development server to see the changes:\nbash Copy code python manage.py runserver Now you should be able to add and edit the fixed table content in the Django admin and see it rendered on your blog_page.html. Adjust the styles and templates according to your design preferences.\nThis guide assumes a basic project structure, so adjust the paths if your project structure is different. Let me know if you have any questions or if there\u0026rsquo;s anything specific you\u0026rsquo;d like to clarify!\nWAGTAIL Upgrade process We recommend upgrading one feature release at a time, even if your project is several versions behind the current one. This has a number of advantages over skipping directly to the newest release:\nIf anything breaks as a result of the upgrade, you will know which version caused it, and will be able to troubleshoot accordingly;\nDeprecation warnings shown in the console output will notify you of any code changes you need to make before upgrading to the following version;\nSome releases make database schema changes that need to be reflected on your project by running ./manage.py makemigrations - this is liable to fail if too many schema changes happen in one go.\nBefore upgrading to a new feature release:\nCheck your project’s console output for any deprecation warnings, and fix them where necessary;\nCheck the new version’s release notes, and the Compatible Django / Python versions table below, for any dependencies that need upgrading first;\nMake a backup of your database.\nTo upgrade:\nUpdate the wagtail line in your project’s requirements.txt file to specify the latest patch release of the version you wish to install. For example, to upgrade to version 1.8.x, the line should read: `wagtail\u0026gt;=1.8,\u0026lt;1.9 Run:\npip install -r requirements.txt ./manage.py makemigrations ./manage.py migrate`\nMake any necessary code changes as directed in the “Upgrade considerations” section of the release notes.\nTest that your project is working as expected.\nRemember that the JavaScript and CSS files used in the Wagtail admin may have changed between releases - if you encounter erratic behaviour on upgrading, ensure that you have cleared your browser cache. When deploying the upgrade to a production server, be sure to run ./manage.py collectstatic to make the updated static files available to the web server. In production, we recommend enabling ManifestStaticFilesStorage in the STATICFILES_STORAGE setting - this ensures that different versions of files are assigned distinct URLs.\nFEEDING DATA FROM DJANGO TO WAGATAIL VIA API Steps:\nTo create a Django API app and expose the data to your Wagtail project, you can follow these steps:\nStep 1: Create Django API App (create a Django app from 0) Open your terminal and navigate to the root directory of your Django project.\nRun the following command to create a new Django app for your API:\npython manage.py startapp django_api_for_wagtail Install the Django REST framework to use it in your Django API app. Django REST framework is a powerful and flexible toolkit for building Web APIs in Django.\nYou can install it using pip. Open your terminal and navigate to your project\u0026rsquo;s root directory. Then, run the following command:\npip3 install djangorestframework After installing, you\u0026rsquo;ll need to add 'rest_framework' to the INSTALLED_APPS in your project\u0026rsquo;s settings.py:\n# myproject/settings.py INSTALLED_APPS = [ # ... \u0026#39;rest_framework\u0026#39;, # ... ] Now that you have a separate app named django_api_for_wagtail for the purpose, let\u0026rsquo;s create a data input example. Assuming you\u0026rsquo;ve created your Nation model within this app, here are the corrected steps:\nDjango API (Django Side): models.py in django_api_for_wagtail app: # django_api_for_wagtail/models.py from django.db import models class Nation(models.Model): name = models.CharField(max_length=255, unique=True) capital = models.CharField(max_length=255) def __str__(self): return self.name serializers.py in django_api_for_wagtail app: # django_api_for_wagtail/serializers.py from rest_framework import serializers from .models import Nation class NationSerializer(serializers.ModelSerializer): class Meta: model = Nation fields = \u0026#39;__all__\u0026#39; views.py in django_api_for_wagtail app: #django_api_for_wagtail/views.py from rest_framework import generics from .models import Nation from .serializers import NationSerializer class NationAPIView(generics.ListCreateAPIView): queryset = Nation.objects.all() serializer_class = NationSerializer urls.py in django_api_for_wagtail app: # django_api_for_wagtail/urls.py from django.urls import path from .views import NationAPIView urlpatterns = [ path(\u0026#39;nations/\u0026#39;, NationAPIView.as_view(), name=\u0026#39;nation-api\u0026#39;), # Add more URL patterns as needed ] admin.py in django_api_for_wagtail app: Here\u0026rsquo;s an example of how you should register the Nation model in the admin.py file:\n# django_api_for_wagtail/admin.py from django.contrib import admin from .models import Nation @admin.register(Nation) class NationAdmin(admin.ModelAdmin): list_display = (\u0026#39;name\u0026#39;, \u0026#39;capital\u0026#39;) urls.py in progetto_api project: To make Django recognize the URLs of your django_api_for_wagtail app, you need to include the URLs of your app in the urls.py file at the project level. You can do this using Django’s include() function, which allows you to reference other URL configurations.\nHere’s how you might update your urls.py file at the project level:Python\nfrom django.contrib import admin from django.urls import include, path urlpatterns = [ path(\u0026#34;admin/\u0026#34;, admin.site.urls), path(\u0026#34;django_api_for_wagtail/\u0026#34;, include(\u0026#39;django_api_for_wagtail.urls\u0026#39;)), ] Test if the steps are correct python3 manage.py makemigrations python3 manage.py migrate If all is ok you can try:\nhttp://127.0.0.1:8000/django_api_for_wagtail/nations/ (frontend side - with json results)\nhttp://127.0.0.1:8000/admin/django_api_for_wagtail/nation/ (backend side - with admin panel)\nIn this way, I can verify the correct data entry on the backend side and the correct management in JSON on the frontend side.\nStep 2: Create Views for API In the api app directory, create a views.py file.\nDefine a view for your API in views.py. For example:\nfrom rest_framework import generics from blog.models import BlogPage from .serializers import BlogPageSerializer class BlogPageAPIView(generics.ListAPIView): queryset = BlogPage.objects.all() serializer_class = BlogPageSerializer Step 3: Configure URLs for API In the api app directory, create a urls.py file.\nDefine the URL patterns for your API in urls.py. For example:\nfrom django.urls import path from .views import BlogPageAPIView urlpatterns = [ path(\u0026#39;blog/\u0026#39;, BlogPageAPIView.as_view(), name=\u0026#39;blog-api\u0026#39;), # Add more URL patterns as needed ] Step 4: Configure Main Project URLs In the main project directory, open the urls.py file.\nInclude the URLs of your API app in the project\u0026rsquo;s URL configuration. Update the urlpatterns:\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;api/\u0026#39;, include(\u0026#39;api.urls\u0026#39;)), # Adjust the URL pattern as needed # Add other URL patterns as needed ] Step 5: Run Migrations and Start the Development Server Run the following commands to apply migrations and start the development server:\nmanage.py makemigrations python manage.py migrate python manage.py runserver Definitive Code for mini Django project API Step 6: create the a frontend (to see the data ) To create a simple frontend to visualize the results from your Django API, you can use Django\u0026rsquo;s built-in templates. Here\u0026rsquo;s a step-by-step guide:\nCreate a templates directory within your django_api_for_wagtail app.\nInside the templates directory, create an HTML file for rendering the nation data. Let\u0026rsquo;s call it nations_list.html.\n\u0026lt;!-- django_api_for_wagtail/templates/nations_list.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Nations List\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Nations List\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {% for nation in nations %} \u0026lt;li\u0026gt;{{ nation.name }} - {{ nation.capital }}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Update your views.py to use this template:\n# django_api_for_wagtail/views.py from django.shortcuts import render from rest_framework import generics from .models import Nation from .serializers import NationSerializer class NationAPIView(generics.ListCreateAPIView): queryset = Nation.objects.all() serializer_class = NationSerializer def list(self, request, *args, **kwargs): nations = self.get_queryset() return render(request, \u0026#39;nations_list.html\u0026#39;, {\u0026#39;nations\u0026#39;: nations}) It is worth to breakdown the code above:\nLet\u0026rsquo;s break down the list method in the NationAPIView class:\n# django_api_for_wagtail/views.py from django.shortcuts import render from rest_framework import generics from .models import Nation from .serializers import NationSerializer class NationAPIView(generics.ListCreateAPIView): queryset = Nation.objects.all() serializer_class = NationSerializer def list(self, request, *args, **kwargs): nations = self.get_queryset() return render(request, \u0026#39;nations_list.html\u0026#39;, {\u0026#39;nations\u0026#39;: nations}) queryset and serializer_class: These are attributes of the NationAPIView class. queryset defines the initial query set of nations, and serializer_class specifies the serializer to be used for serializing the data. list method: This method is part of the ListCreateAPIView class provided by Django REST Framework. It handles the HTTP GET request for the list view. self.get_queryset(): This method retrieves the query set of nations. In this case, it gets all the objects from the Nation model specified in the queryset attribute. render function: This function is used to render an HTML template. It takes the following parameters: request: The HTTP request object. 'nations_list.html': The name of the template file to be rendered. {'nations': nations}: A dictionary containing data to be passed to the template. In this case, it includes the retrieved nations from the query set. return render(...): This line returns the rendered HTML content as an HTTP response. The rendered content will be the result of applying the data from the nations query set to the \u0026rsquo;nations_list.html\u0026rsquo; template. In summary, when a user accesses the URL associated with the NationAPIView, the list method is called. It retrieves the list of nations, passes them to the \u0026rsquo;nations_list.html\u0026rsquo; template, renders the HTML content, and returns it as an HTTP response. This allows you to view a list of nations in a web browser when accessing the corresponding URL.\nLet\u0026rsquo;s break down the list method in more detail:\nlist(self, request, *args, **kwargs): nations = self.get_queryset() return render(request, \u0026#39;nations_list.html\u0026#39;, {\u0026#39;nations\u0026#39;: nations}) self: In Python, self is a convention for referring to the instance of the class. In this context, it represents an instance of the NationAPIView class.\nrequest: This is the HTTP request object that is passed to the view. It contains information about the incoming request, such as the method (GET, POST, etc.), headers, and any data sent in the request.\n\\*args and \\**kwargs: These are used to collect additional positional and keyword arguments. In this case, they are not used in the method body, but the method signature includes them to allow flexibility.The usage of *args and **kwargs provides flexibility when defining functions or methods that can accept a variable number of arguments.\nUsing \\*args for Variable Positional Arguments: example_function(*args): for arg in args: print(arg) example_function(1, 2, 3, \u0026#39;four\u0026#39;) In this example, *args allows the function to accept any number of positional arguments. It collects them into a tuple named args, and the function can iterate over them.\nUsing \\**kwargs for Variable Keyword Arguments:\nexample_function(**kwargs): for key, value in kwargs.items(): print(f\u0026#34;{key}: {value}\u0026#34;) example_function(name=\u0026#39;John\u0026#39;, age=25, city=\u0026#39;New York\u0026#39;) In this example, **kwargs allows the function to accept any number of keyword arguments. It collects them into a dictionary named kwargs, and the function can iterate over the key-value pairs.\nCombining \\*args and \\**kwargs:\nexample_function(arg1, arg2, *args, **kwargs): print(f\u0026#34;arg1: {arg1}\u0026#34;) print(f\u0026#34;arg2: {arg2}\u0026#34;) print(f\u0026#34;Additional positional arguments: {args}\u0026#34;) print(f\u0026#34;Additional keyword arguments: {kwargs}\u0026#34;) example_function(1, 2, 3, 4, key1=\u0026#39;value1\u0026#39;, key2=\u0026#39;value2\u0026#39;) In this example, arg1 and arg2 are regular positional arguments, *args collects additional positional arguments into a tuple, and **kwargs collects additional keyword arguments into a dictionary.\nUsing *args and **kwargs allows a function or method to be more flexible and accommodate a varying number of arguments without explicitly specifying them in the function signature. This is particularly useful in cases where the number of arguments might change or when writing functions that need to work with a wide range of inputs.\nself.get_queryset(): This method is inherited from the ListCreateAPIView class of Django REST Framework. It retrieves the queryset of nations. The get_queryset method is responsible for returning the list of objects that will be used in the view.\nnations: This variable stores the queryset of nations obtained from self.get_queryset().\nrender(request, 'nations_list.html', {'nations': nations}): The render function is a shortcut provided by Django for rendering an HTML template. It takes the following arguments:\nrequest: The HTTP request object. 'nations_list.html': The name of the HTML template file to be rendered. {'nations': nations}: A dictionary containing data to be passed to the template. In this case, it includes the list of nations obtained from the queryset. return render(...): This line returns the rendered HTML content as an HTTP response. The rendered content will be the result of applying the data from the nations queryset to the \u0026rsquo;nations_list.html\u0026rsquo; template. In summary, the list method is responsible for retrieving a queryset of nations and rendering an HTML template (\u0026rsquo;nations_list.html\u0026rsquo;) with the nations\u0026rsquo; data. The rendered HTML content is then returned as an HTTP response. This is a common pattern for providing a list view in a Django REST Framework API.\nUpdate your urls.py to include a URL pattern for rendering the nations list: # django_api_for_wagtail/urls.py from django.urls import path from .views import NationAPIView urlpatterns = [ path(\u0026#39;nations/\u0026#39;, NationAPIView.as_view(), name=\u0026#39;nation-api\u0026#39;), path(\u0026#39;nations/list/\u0026#39;, NationAPIView.as_view(), name=\u0026#39;nations-list\u0026#39;), # Add more URL patterns as needed ] Finally, update your urls.py at the project level to include the django_api_for_wagtail URLs:\n# progetto_api/urls.py from django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;admin/\u0026#39;, admin.site.urls), path(\u0026#39;django_api_for_wagtail/\u0026#39;, include(\u0026#39;django_api_for_wagtail.urls\u0026#39;)), ] Now, when you visit the URL http://127.0.0.1:8000/django_api_for_wagtail/nations/list/, it should render the nations list using the template.\nFino a qui\nStep 6: Access the API Open your web browser and navigate to http://127.0.0.1:8000/api/blog/ (or the URL you configured). You should see the serialized data from your Wagtail model. Step 7: Integrate with Wagtail In your Wagtail project, you can now fetch data from the API endpoint (http://127.0.0.1:8000/api/blog/) using Django\u0026rsquo;s requests library or any other method you prefer. Use the retrieved data to populate your Wagtail views/templates as needed. This is a basic setup, and you may need to customize it based on your specific requirements. Additionally, you might want to add authentication and permission controls to secure your API.\nWAGTAIL COMPATIBILITY WITH DJANGO ## - link PYTHON Spiegazione attraverso codice di init, getattribute e super Spesso nei moduli di wagtail si fa riferimento alla classazione e subclassazione. Avere chiri alcuni termini è necessario. Questa è la breve sintesi attraverso un sempio\nclass Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;)` This is a simple class representing a vehicle with a brand. It has an init method that initializes the brand attribute and a start method to print a message when the vehicle starts. Car (inherits from Vehicle):\npython Copy code class Car(Vehicle): def init(self, brand, model): # No use of super() self.model = model\ndef start(self): print(f\u0026quot;{self.brand} {self.model} car started.\u0026quot;) This class represents a specific type of vehicle, a Car, inheriting from the Vehicle class. It has its own init method, but it doesn\u0026rsquo;t use super(), and it has a start method that overrides the start method in the Vehicle class. CarWithSuper (inherits from Car):\nclass CarWithSuper(Car): def init(self, brand, model, color): super().init(brand, model) self.color = color\ndef start(self): super().start() print(f\u0026quot;The {self.color} car is ready to go.\u0026quot;) def __getattribute__(self, name): # Modifying __getattribute__ to add a prefix to the brand attribute if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__(name) else: return super().__getattribute__(name) This class inherits from Car and introduces a new attribute color. It uses super() in the init method to call the init method of the parent class (Car). It overrides the start method, calls the parent\u0026rsquo;s start method using super(), and adds an additional message. It also modifies getattribute to add a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the brand attribute. Examples: Example without super(), init, and getattribute:\ncar_without_super = Car(brand=\u0026quot;Toyota\u0026quot;, model=\u0026quot;Camry\u0026quot;) print(car_without_super.model) # Output: Camry An instance of Car is created without using super(). __init__ in Car is called, but __init__ of the parent (Vehicle) is not called. start method from Vehicle is not available in car_without_super. Example with super(), __init__, and __getattribute__: car_with_super = CarWithSuper(brand=\u0026quot;Ford\u0026quot;, model=\u0026quot;Mustang\u0026quot;, color=\u0026quot;red\u0026quot;) print(car_with_super.brand) # Output: Awesome Ford car_with_super.start() # Output: Ford Mustang car started. The red car is ready to go.\nAn instance of CarWithSuper is created using super() to call init of the parent (Car). getattribute is modified to add a prefix to the brand attribute. start method calls the parent\u0026rsquo;s (Car) start method using super() and adds an additional message. Roles:\ninit: Used for initializing the attributes of an object. In the inheritance chain, it\u0026rsquo;s common to use super().init(\u0026hellip;) to call the initializer of the parent class.\ngetattribute: Called whenever an attribute of an object is accessed. Can be modified to customize attribute access. Used here to modify the behavior of accessing the brand attribute.\nsuper(): Used to refer to the parent class. In init, it\u0026rsquo;s used to call the initializer of the parent class. In methods, it\u0026rsquo;s used to call methods from the parent class. In the provided example, super() helps maintain the hierarchy in inheritance, ensuring that the methods of the parent classes are appropriately called. init is used for object initialization, and getattribute is modified to customize attribute access.\nVediamo ora cosa succede se non utilizziamo i metodi Assenza di init If you don\u0026rsquo;t use the init method in the Vehicle class, the class will still be valid, but instances of the class won\u0026rsquo;t have a constructor to initialize their state. The init method is a special method in Python classes that is automatically called when an object is created. It is used for initializing the attributes of the object.\nHere\u0026rsquo;s what happens when you don\u0026rsquo;t include init:\npython Copy code class Vehicle: def start(self): print(\u0026ldquo;Vehicle started.\u0026rdquo;)\nCreating an instance without init vehicle_instance = Vehicle()\nThis will not raise an error, but the instance won\u0026rsquo;t have a \u0026lsquo;brand\u0026rsquo; attribute. If you try to access \u0026lsquo;brand\u0026rsquo;, it will result in an AttributeError. print(vehicle_instance.start()) # Output: Vehicle started. print(vehicle_instance.brand) # AttributeError: \u0026lsquo;Vehicle\u0026rsquo; object has no attribute \u0026lsquo;brand\u0026rsquo; In the example above, creating an instance of Vehicle without an init method is allowed. However, without an init method, instances won\u0026rsquo;t have any attributes initialized during instantiation. If you try to access an attribute that hasn\u0026rsquo;t been defined, you will get an AttributeError.\nIncluding the init method allows you to initialize the state of an object when it is created. For example:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) Creating an instance with init vehicle_instance = Vehicle(brand=\u0026ldquo;Toyota\u0026rdquo;)\nNow, the \u0026lsquo;brand\u0026rsquo; attribute is initialized during instantiation. print(vehicle_instance.start()) # Output: Toyota vehicle started. print(vehicle_instance.brand) # Output: Toyota In the second example, the init method is used to initialize the brand attribute when a Vehicle instance is created. This ensures that the instance has a properly initialized state from the beginning.\nEd ora quando posso usare e non usare getattribute?### If you don\u0026rsquo;t define the getattribute method in a class, Python will use the default behavior for attribute access. The default behavior involves looking up the attribute in the object\u0026rsquo;s dictionary and returning its value if found. If the attribute is not found in the object\u0026rsquo;s dictionary, Python looks for the attribute in the class hierarchy.\nHere\u0026rsquo;s what happens if you don\u0026rsquo;t use getattribute:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) Creating an instance without getattribute vehicle_instance = Vehicle(brand=\u0026ldquo;Toyota\u0026rdquo;)\nAccessing the \u0026lsquo;brand\u0026rsquo; attribute without a custom getattribute print(vehicle_instance.brand) # Output: Toyota\nThe default behavior is used, and there is no need for a custom getattribute in this case. In the example above, we create a Vehicle class with an init method to initialize the brand attribute. When we access the brand attribute, the default attribute access behavior is used, and there is no need for a custom getattribute. The attribute is found in the instance\u0026rsquo;s dictionary, and its value is returned.\nThe getattribute method is a powerful tool for customizing attribute access, and it allows you to intercept attribute access calls and customize the behavior. However, in many cases, you may not need to override it, and the default behavior is sufficient for basic attribute access. Only when you need to customize the attribute access behavior should you consider defining a getattribute method.\nIn the example provided, the getattribute method is used to customize the behavior of accessing the brand attribute in the CarWithSuper class. Specifically, it adds a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the value of the brand attribute before returning it.\nHere\u0026rsquo;s the relevant part of the code:\npython Copy code class CarWithSuper(Car): # \u0026hellip;\ndef __getattribute__(self, name): # Modifying __getattribute__ to add a prefix to the brand attribute if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__(name) else: return super().__getattribute__(name) In this case, the getattribute method is modifying the behavior of accessing the brand attribute. Without this customization, accessing car_with_super.brand would simply return the value of the brand attribute. With the custom getattribute, it returns the value with the added prefix.\nSo, you might need to use getattribute when you want to customize or intercept attribute access calls and modify the behavior based on your specific requirements. It\u0026rsquo;s a powerful tool, but it should be used judiciously, as unnecessary or incorrect use may lead to unexpected behavior and potential issues.\nMIXIN L\u0026rsquo;esempio esposto e che di seguito si ripropone risulta anche un ottimo esempio di mixin\nYes, the provided example with Vehicle, Car, and CarWithSuper can be considered an example of mixin-like behavior. Let me break it down:\nVehicle Class:\npython Copy code class Vehicle: def init(self, brand): self.brand = brand\ndef start(self): print(f\u0026quot;{self.brand} vehicle started.\u0026quot;) This is the base class representing a generic vehicle. It has an init method to initialize the brand attribute and a start method.\nCar Class (Inherits from Vehicle):\npython Copy code class Car(Vehicle): def init(self, brand, model): super().init(brand) self.model = model\ndef start(self): print(f\u0026quot;{self.brand} {self.model} car started.\u0026quot;) The Car class inherits from Vehicle. It has its own init method but uses super() to call the init method of the parent class (Vehicle). It also has its own start method, overriding the start method of Vehicle.\nCarWithSuper Class (Inherits from Car):\npython Copy code class CarWithSuper(Car): def init(self, brand, model, color): super().init(brand, model) self.color = color\ndef start(self): super().start() print(f\u0026quot;The {self.color} car is ready to go.\u0026quot;) def __getattribute__(self, name): if name == \u0026quot;brand\u0026quot;: return \u0026quot;Awesome \u0026quot; + super().__getattribute__('brand') else: return super().__getattribute__(name) The CarWithSuper class inherits from Car and introduces a new attribute (color). It uses super() to call the init method of the parent class (Car). It also overrides the start method, calling the parent\u0026rsquo;s (Car) start method using super() and adding an additional message. Additionally, it modifies getattribute to add a prefix (\u0026ldquo;Awesome\u0026rdquo;) to the brand attribute.\nSo, in this example, the classes are organized in a way that exhibits mixin-like behavior. The CarWithSuper class enhances the behavior of the Car class by adding attributes and modifying methods, and it uses super() to maintain the hierarchy and call methods from parent classes. While it may not strictly adhere to the classic definition of a mixin, it shares some characteristics of mixin-like behavior.\nDefinizione di mixin In object-oriented programming, a mixin is a class that provides a certain functionality to be inherited by a subclass, but is not meant to stand alone. Mixins are used to enhance the functionality of a class without the need for multiple inheritance.\nHere are some key characteristics and features of mixins:\nPurpose-Specific Functionality: Mixins are designed to provide a specific set of functionalities or behaviors that can be easily added to other classes. They encapsulate a piece of behavior.\nReusability: Mixins promote code reuse. Instead of duplicating code in multiple classes, you can create a mixin and include it in various classes that need that particular behavior.\nNo Standalone Use: Mixins are not meant to be instantiated or used independently. They lack the complete implementation to be used as standalone classes. They are intended to be combined with other classes.\nFlexible Composition: Since a class can inherit from multiple mixins, it allows for flexible composition of functionalities. This is in contrast to languages that do not support multiple inheritance directly.\nAvoids Diamond Problem: Mixins can help avoid the \u0026ldquo;diamond problem\u0026rdquo; that arises in languages with multiple inheritance, where a class inherits from two classes that have a common ancestor.\nSmall and Focused: Mixins are typically small and focused on a specific task. This makes them easy to understand, maintain, and reuse.\nSTANDARD COMMANDS IN DJANGO INSTALLATION# python3 -m venv venv USEFUL PROPERTY AND METHOD IN DJANGO L\u0026rsquo;uso di Queryset Django querysets have several notable properties and methods that provide flexibility and ease of use when interacting with the database. Here are some key properties and methods of querysets:\nChaining:\nQuerysets are lazy, meaning they don\u0026rsquo;t hit the database until an action is performed. Multiple filters and operations can be chained together to build complex queries. Example:\npython Copy code queryset = Model.objects.filter(field1=value1).exclude(field2=value2).order_by(\u0026rsquo;-date_created\u0026rsquo;) Slicing:\nQuerysets can be sliced to retrieve a specific range of objects. Example:\npython Copy code queryset = Model.objects.all() result_slice = queryset[5:10] # Retrieve objects 5 through 9 Count:\nThe count method returns the number of objects in the queryset without fetching the actual objects. Example:\npython Copy code count = queryset.count() Distinct:\nThe distinct method eliminates duplicate rows from the queryset. Example:\npython Copy code distinct_values = Model.objects.values(\u0026lsquo;field\u0026rsquo;).distinct() Aggregate:\nThe aggregate method allows for the calculation of aggregate values (e.g., sum, average) on the queryset. Example:\npython Copy code from django.db.models import Avg average_value = Model.objects.aggregate(avg_value=Avg(\u0026rsquo;numeric_field\u0026rsquo;)) Values and ValuesList:\nThe values method returns a queryset of dictionaries representing the values of specific fields. The values_list method returns a queryset of tuples representing the values of specific fields. Example:\npython Copy code values_queryset = Model.objects.values(\u0026lsquo;field1\u0026rsquo;, \u0026lsquo;field2\u0026rsquo;) values_list_queryset = Model.objects.values_list(\u0026lsquo;field1\u0026rsquo;, \u0026lsquo;field2\u0026rsquo;) Exists:\nThe exists method checks if there are any records in the queryset. Example:\nqueryset_exists = Model.objects.filter(field=value).exists() Update and Delete:\nThe update method modifies multiple records in the database without fetching them. The delete method deletes records from the database without fetching them. Example:\npython Copy code Model.objects.filter(field=value).update(status=\u0026lsquo;new_status\u0026rsquo;) Model.objects.filter(field=value).delete() These are just a few of the many properties and methods provided by Django querysets. They offer a powerful and expressive way to interact with the database.\nEsempio in wagtail from datetime import datetime, timedelta, timezone from django.shortcuts import render from wagtail.core.models import Page from your_app.models import RoundPage # Replace \u0026lsquo;your_app\u0026rsquo; with the actual name of your app from path.to.get_deadline_date_for import get_deadline_date_for # Replace \u0026lsquo;path.to\u0026rsquo; with the actual path\ndef docs_internship(request): now = datetime.now(timezone.utc) today = get_deadline_date_for(now) five_weeks_ago = today - timedelta(days=7 * 5)\napplicant_round = RoundPage.objects.filter( pingnew__lte=today, internannounce__gt=today, ).first() intern_round = RoundPage.objects.filter( internannounce__lte=today, internends__gt=five_weeks_ago, ).first() return render(request, 'home/docs/internship_guide.html', { 'applicant_round': applicant_round, 'intern_round': intern_round, }) # Strumenti avanzati: Creare una pagina wagtail all\u0026rsquo;interno di un sito Django (link)[https://docs.wagtail.org/en/latest/advanced_topics/add_to_django_project.html]\nInstallazione in Django al pari livello di manage.py: python3 manage.py startapp blog_wiki_wag\nVerifica in Wagtail di requirements.txt della compatibilità delle versioni tra Django e Wagtail. Nel caso specifico Django\u0026gt;=4.2,\u0026lt;4.3 - wagtail\u0026gt;=5.1,\u0026lt;5.2\nVerifica in Django di requirements.txt: Django==4.2.2\nSe vi è compatibilità in Wagtal: pip3 freeze requriments.txt\n*** Verifica del motore Database in Wagtail in base.py: ***\nDATABASES = { \u0026quot;default\u0026quot;: { \u0026quot;ENGINE\u0026quot;: \u0026quot;django.db.backends.sqlite3\u0026quot;, \u0026quot;NAME\u0026quot;: os.path.join(BASE_DIR, \u0026quot;db.sqlite3\u0026quot;), } }\n*** Verifica del motore database in Django in settings.py: ***\nDATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': BASE_DIR / 'db.sqlite3', } }\nCome si può vedere sopra i due motori DB sono identici\nOra creare la subdirectory di progetto wagtail che conterrà tutti i file dell\u0026rsquo;app wagtail (quella con il quale si effettuato il requirements.txt)\neffettuare il clone del branch da GB del progetto wagtail (vedere git e github per i dettagli)\na questo punto lanciare il comando Install the Project:\nNavigate to the wagtail-wag directory in your terminal: pip install -r requirements.txt\nAdd Wagtail URLs to Django URLs: path('wagtail/', include('wiki-wag.wagtail_urls')), # nuovo inserimento\nAdd the required wagtail modules in setting.py: `INSTALLED_APPS = [\n\u0026lsquo;wagtail.contrib.forms\u0026rsquo;, \u0026lsquo;wagtail.contrib.redirects\u0026rsquo;, \u0026lsquo;wagtail.embeds\u0026rsquo;, \u0026lsquo;wagtail.sites\u0026rsquo;, \u0026lsquo;wagtail.users\u0026rsquo;, \u0026lsquo;wagtail.snippets\u0026rsquo;, \u0026lsquo;wagtail.documents\u0026rsquo;, \u0026lsquo;wagtail.images\u0026rsquo;, \u0026lsquo;wagtail.search\u0026rsquo;, \u0026lsquo;wagtail.admin\u0026rsquo;,\n\u0026rsquo;taggit\u0026rsquo;, \u0026lsquo;modelcluster\u0026rsquo;,\n\u0026lsquo;django.contrib.admin\u0026rsquo;, \u0026lsquo;django.contrib.auth\u0026rsquo;, \u0026lsquo;django.contrib.contenttypes\u0026rsquo;, \u0026lsquo;django.contrib.sessions\u0026rsquo;, \u0026lsquo;django.contrib.messages\u0026rsquo;, \u0026lsquo;django.contrib.staticfiles\u0026rsquo;, \u0026lsquo;sgq\u0026rsquo;, \u0026lsquo;wagtail\u0026rsquo;, ]`\nAdd\u0026rsquo;wiki-wag\u0026rsquo; app in your Django INSTALLED_APPS as well. Add it if it\u0026rsquo;s not present.\nINSTALLED_APPS = [ # \u0026hellip; \u0026lsquo;wiki-wag\u0026rsquo;, # \u0026hellip; ]\nadd in Django settings this: ` MIDDLEWARE = [ \u0026lsquo;django.contrib.sessions.middleware.SessionMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.common.CommonMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.csrf.CsrfViewMiddleware\u0026rsquo;, \u0026lsquo;django.contrib.auth.middleware.AuthenticationMiddleware\u0026rsquo;, \u0026lsquo;django.contrib.messages.middleware.MessageMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.clickjacking.XFrameOptionsMiddleware\u0026rsquo;, \u0026lsquo;django.middleware.security.SecurityMiddleware\u0026rsquo;,\n\u0026lsquo;wagtail.contrib.redirects.middleware.RedirectMiddleware\u0026rsquo;, ] `\nA questo punto dvrebbe apparire un Warning che indica qualcosa di questo genere :::caution WARNINGS: ?: (wagtailadmin.W003) The WAGTAILADMIN_BASE_URL setting is not defined HINT: This should be the base URL used to access the Wagtail admin site. Without this, URLs in notification emails will not display correctly :::\nProseguire e verificare se in admin panel appaiono gli elementi di inpunt in Admin Panel\nSo now update the urls and run makemirgations and migrate from django.contrib import admin from django.urls import path, include from wagtail import urls as wagtail_urls\nurlpatterns = [ path(\u0026rsquo;\u0026rsquo;, include(\u0026lsquo;sgq.urls\u0026rsquo;)), # Include the app-level URLs path(\u0026lsquo;admin/\u0026rsquo;, admin.site.urls), # path(\u0026lsquo;wagtail/\u0026rsquo;, include(\u0026lsquo;wagtail.core.urls\u0026rsquo;)), # nuovo inserimento path(\u0026lsquo;wagtail/\u0026rsquo;, include(wagtail_urls)), # nuovo inserimento\n]\nDJANGO Create a Django App from 0 (from Create Django API App ) Step 1: Create a Virtual Environment (Optional but recommended) Open your terminal and navigate to the directory where you want to create your Django project. Run the following commands:\npython3 -m venv venv source venv/bin/activate Step 2: Install Django While in the activated virtual environment, install Django using the following command:\npip3 install django Step 3: Create a Django Project\nRun the following command to create a new Django project:\ndjango-admin startproject progetto_api Replace myproject with the desired name for your project.\nStep 4: Navigate to the Project Directory Change into the project directory:\ncd progetto_api Step 5: Create a Django App Run the following command to create a new Django app:\npython3 manage.py startapp django_api_for_wagtail Step 6: Configure Database Open the myproject/settings.py file and configure the app and the database settings. By default, Django uses SQLite for development (if not already configured):\n# myproject/settings.py INSTALLED_APPS = [ # ... \u0026#39;django_api_for_wagtail\u0026#39;, # ... ] # .... # DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: BASE_DIR / \u0026#34;db.sqlite3\u0026#34;, } } Step 7: Apply Migrations Run the following commands to apply initial migrations:\npython3 manage.py makemigrations python3 manage.py migrate Step 8: Create a Superuser (Optional but recommended) Run the following command to create a superuser account for the Django admin:\nbashCopy code python manage.py createsuperuser Follow the prompts to set a username, email, and password.\nStep 9: Run the Development Server Start the Django development server:\npython3 manage.py runserver Visit http://127.0.0.1:8000/ in your web browser to see the Django welcome page.\nStep 10: Create a Superuser After running the development server return e to your project directory (at manage.py level).\nRun the following command to create a superuser account:\npython3 manage.py createsuperuser Follow the prompts to set a username, email, and password for the superuser account.\nStep 11: Run the Development Server Ensure that the development server is still running:\npython3 manage.py runserver Step 12: Open the Admin Interface Visit http://127.0.0.1:8000/admin/ in your web browser. Log in with the superuser credentials you just created.\nStep 13: Verify Admin Interface Verify that the Django admin interface is working correctly\nStep 14: Initialize a Git Repository Open a new terminal window in your project directory\nThe Git commands to initialize a repository, add files, and make an initial commit should be executed at the root level of your project, where your manage.py file is located. The manage.py file is typically located at the top level of your Django project, not within the virtual environment (venv).\nRun the following commands to initialize a Git repository, add all files, and make an initial commit:\ngit init git add . git commit -m \u0026#34;Initial commit\u0026#34; Step 15: Create a GitHub Repository Go to the GitHub website and log in or create a new account. Click on the \u0026ldquo;+\u0026rdquo; icon in the top right corner and select \u0026ldquo;New repository.\u0026rdquo; Follow the instructions to create a new repository on GitHub. git repo name https://github.com/progettazionemauro/django-api Step 16: Connect Local Repository to GitHub After creating the GitHub repository follow those instructions.\ngit remote add origin https://github.com/progettazionemauro/django-api\ngit branch -M main\nnote: The git branch -M main command is used to rename the current branch. In Git, it\u0026rsquo;s a way to both rename the current branch and force-update the tracking branches.\nHere\u0026rsquo;s what the command does:\ngit branch: This command is used for creating, listing, renaming, and deleting branches in Git. When used without additional options, it lists all the local branches. -M main: This option is used to rename the current branch to \u0026ldquo;main\u0026rdquo;. The -M flag is a shortcut for --move, which is used for renaming branches. When you create a new Git repository or clone an existing one, the default branch is usually named \u0026ldquo;master.\u0026rdquo; However, in recent years, there has been a movement in the Git community to use more inclusive and neutral terminology. As a result, many projects are now using \u0026ldquo;main\u0026rdquo; instead of \u0026ldquo;master\u0026rdquo; as the default branch name.\nThe git branch -M main command is often used after creating a new repository or when transitioning from \u0026ldquo;master\u0026rdquo; to \u0026ldquo;main\u0026rdquo; to update the branch name.\nIt\u0026rsquo;s important to note that if you\u0026rsquo;re renaming the branch you are currently on, you might need to update the remote repository to reflect the new branch name.\ngit remote add origin https://github.com/progettazionemauro/django-api git branch -M main git push -u origin main Make sure to replace \u0026ldquo;your-username\u0026rdquo; and \u0026ldquo;your-repo\u0026rdquo; with your GitHub username and repository name.\nStep 16 bis: problems with git push In doing push it can happen to find issues related to pushing for the first time into Github. For example when you created the repo and added readme.md and it is not present into local repo this can generate a misealignment that che lead to generate an error likse that:\ngit push origin main `To https://github.com/progettazionemauro/django-api` `! [rejected] main -\u0026gt; main (non-fast-forward)` `error: push di alcuni riferimenti su \u0026#39;https://github.com/progettazionemauro/django-api\u0026#39; non riuscito` `suggerimento: Gli aggiornamenti sono stati rifiutati perché l\u0026#39;ultimo commit del branch` `suggerimento: attuale è rimasto indietro rispetto alla sua controparte remota.` `suggerimento: Integra le modifiche remote (ad es. con \u0026#39;git pull ...\u0026#39;) prima di` `suggerimento: eseguire nuovamente il push.` `suggerimento: Vedi la \u0026#39;Nota sui fast forward\u0026#39; in \u0026#39;git push --help\u0026#39; per ulteriori` `suggerimento: dettagli.` So it this is the case the best option if to do this:\nIn alternativa, puoi anche eseguire il comando:git push --force per forzare il push delle tue modifiche, anche se non sono un fast forward. Tuttavia, questa è una soluzione rischiosa perché potrebbe sovrascrivere le modifiche remote che non hai ancora integrato nel tuo branch locale.\nPer capire meglio cosa significa \u0026ldquo;non-fast-forward\u0026rdquo;, è necessario comprendere il concetto di fast forward. Un fast forward è un tipo di push che aggiorna un branch locale con le ultime modifiche apportate a un branch remoto. Il fast forward è possibile solo se le modifiche apportate ai due branch sono consecutive.\nStep 16: Verify GitHub Repository Go to your GitHub repository in the web browser and verify that your code has been pushed successfully.\nThat\u0026rsquo;s it! Now you have a Django project with a superuser account, and your code is version-controlled using Git and hosted on GitHub.\nStep 10: Create Models, Views, and Templates (Optional) You can now start building your Django app by creating models, views, and templates. Define your models in the models.py file, create views in the views.py file, and add templates in the templates directory.\nStep 11: Create API App (Optional) If you want to create a separate app for your API, follow the instructions provided in the previous response to create an api app and set up serializers, views, and URLs.\nThat\u0026rsquo;s it! You now have a basic Django project and app set up. Customize it based on your specific requirements and integrate it with your Wagtail project as needed.\n","permalink":"http://localhost:1313/posts/manuale_di_installazione/","summary":"[toc]\nMARKUP HINTS I have my README.md inside my project. Here are a method to work with your README.md separately while working on your vsc local project: Use an external Markdown editor like\n** (a minimal markdown editor and reader) **. These editors provide a live preview feature by default.\nBASH trovare la oporta occupata:\nlsof -i :8000 chiudere la porta occupata forzatamente:\nkill -9 32394(esempio) vedere i comandi che iniziano per una determinata strina effettuati in precedenza:","title":"Manuale di installazione"},{"content":"Io sto studiando Hugo, un passo alla volta! Speriamo che funzioni\n","permalink":"http://localhost:1313/about_map/about/","summary":"Io sto studiando Hugo, un passo alla volta! Speriamo che funzioni","title":"ABOUT"},{"content":"","permalink":"http://localhost:1313/posts/search/","summary":"search","title":"Pagina di ricerca"}]